{"ast":null,"code":"import \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Line series module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { XYSeries, XYSeriesDataItem } from \"./XYSeries\";\nimport { visualProperties } from \"../../core/Sprite\";\nimport { Container } from \"../../core/Container\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { LineSeriesSegment } from \"./LineSeriesSegment\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { DateAxis } from \"../axes/DateAxis\";\nimport { DurationAxis } from \"../axes/DurationAxis\";\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\nimport { registry } from \"../../core/Registry\";\nimport { Line } from \"../../core/elements/Line\";\nimport { Label } from \"../../core/elements/Label\";\nimport { Rectangle } from \"../../core/elements/Rectangle\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $array from \"../../core/utils/Array\";\nimport { Bullet } from \"../elements/Bullet\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines a [[DataItem]] for [[LineSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar LineSeriesDataItem = /** @class */function (_super) {\n  __extends(LineSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function LineSeriesDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"LineSeriesDataItem\";\n    return _this;\n  }\n  return LineSeriesDataItem;\n}(XYSeriesDataItem);\nexport { LineSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines [[Series]] for a line graph.\r\n *\r\n * @see {@link ILineSeriesEvents} for a list of available Events\r\n * @see {@link ILineSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\nvar LineSeries = /** @class */function (_super) {\n  __extends(LineSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n  function LineSeries() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Minimum distance in pixels between two adjacent points.\r\n     *\r\n     * If the distance is less than this setting, a point is skipped.\r\n     *\r\n     * This allows acceptable performance with huge amounts of data points.\r\n     *\r\n     * @default 0.5\r\n     */\n    _this.minDistance = 0.5;\n    _this.segments = new ListTemplate(_this.createSegment());\n    _this.segments.template.applyOnClones = true;\n    _this._disposers.push(new ListDisposer(_this.segments));\n    _this._disposers.push(_this.segments.template);\n    _this._segmentsIterator = new $iter.ListIterator(_this.segments, function () {\n      return _this.segments.create();\n    });\n    _this._segmentsIterator.createNewItems = true;\n    _this.className = \"LineSeries\";\n    _this.strokeOpacity = 1;\n    _this.fillOpacity = 0;\n    _this.connect = true;\n    _this.tensionX = 1;\n    _this.tensionY = 1;\n    _this.autoGapCount = 1.1;\n    _this.smoothing = \"bezier\";\n    _this.segmentsContainer = _this.mainContainer.createChild(Container);\n    _this.segmentsContainer.isMeasured = false;\n    // line series might have multiple segments and it has a separate sprite for fill and stroke for each segment. So we need to observe all the changes on series and set them on the segments\n    // todo: we need list here, otherwise everything will be redrawn event on change of properties like tooltipX or similar.\n    // this.addEventListener(SpriteEvent.PROPERTY_CHANGED, this.validateDataElements, false, this);\n    _this.bulletsContainer.toFront();\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n  LineSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Line Series\");\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  LineSeries.prototype.createSegment = function () {\n    return new LineSeriesSegment();\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  LineSeries.prototype.createDataItem = function () {\n    return new LineSeriesDataItem();\n  };\n  /**\r\n   * Inits data item's working values.\r\n   *\r\n   * @param dataItem  Data item\r\n   * @param index     Data item's index\r\n   */\n  LineSeries.prototype.setInitialWorkingValues = function (dataItem) {\n    // this makes data items animate when added\n    var yAxis = this._yAxis.get();\n    var xAxis = this._xAxis.get();\n    if (this.appeared && this.visible) {\n      var previousDataItem = this.dataItems.getIndex(dataItem.index - 1);\n      dataItem.component = this; // as these values are set before, we don't know component yet\n      if (this.baseAxis == xAxis) {\n        if (yAxis instanceof ValueAxis) {\n          var initialY = yAxis.minZoomed;\n          if (previousDataItem) {\n            initialY = previousDataItem.values[\"valueY\"].workingValue;\n          }\n          // this makes line animate from previous point to newly added point\n          dataItem.setWorkingValue(\"valueY\", initialY, 0);\n          dataItem.setWorkingValue(\"valueY\", dataItem.values.valueY.value);\n          if (xAxis instanceof DateAxis) {\n            dataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX - 1, 0); // instantly move it to previous\n            dataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX); // animate to it's location\n          } else if (xAxis instanceof DurationAxis) {\n            if (previousDataItem) {\n              var value = dataItem.valueX;\n              dataItem.setWorkingValue(\"valueX\", previousDataItem.valueX, 0); // instantly move it to previous\n              dataItem.setWorkingValue(\"valueX\", value); // animate to new value\n            }\n          }\n        }\n      }\n      if (this.baseAxis == yAxis) {\n        if (xAxis instanceof ValueAxis) {\n          var initialX = xAxis.minZoomed;\n          if (previousDataItem) {\n            initialX = previousDataItem.values[\"valueX\"].workingValue;\n          }\n          dataItem.setWorkingValue(\"valueX\", initialX, 0);\n          dataItem.setWorkingValue(\"valueX\", dataItem.values.valueX.value);\n          if (yAxis instanceof DateAxis) {\n            dataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateX - 1, 0); // instantly move it to previous\n            dataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateY); // animate to it's location\n          } else if (yAxis instanceof DurationAxis) {\n            if (previousDataItem) {\n              var value = dataItem.valueY;\n              dataItem.setWorkingValue(\"valueY\", previousDataItem.valueY, 0); // instantly move it to previous\n              dataItem.setWorkingValue(\"valueY\", value); // animate to new value\n            }\n          }\n        }\n      }\n    } else {\n      if (this.baseAxis == xAxis) {\n        if (yAxis instanceof ValueAxis) {\n          if (xAxis instanceof DateAxis) {\n            dataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX);\n          }\n          if (xAxis instanceof CategoryAxis) {\n            dataItem.setWorkingLocation(\"categoryX\", dataItem.locations.categoryX);\n          }\n        }\n      }\n      if (this.baseAxis == yAxis) {\n        if (xAxis instanceof ValueAxis) {\n          if (yAxis instanceof DateAxis) {\n            dataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateY);\n          }\n          if (yAxis instanceof CategoryAxis) {\n            dataItem.setWorkingLocation(\"categoryY\", dataItem.locations.categoryY);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Updates corresponding legend data item with current values.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n  LineSeries.prototype.updateLegendValue = function (dataItem, notRange) {\n    _super.prototype.updateLegendValue.call(this, dataItem, notRange);\n    //This is hack to save some methos, used to set tooltip color source only\n    if (dataItem && dataItem.segment) {\n      this.tooltipColorSource = dataItem.segment;\n    }\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  LineSeries.prototype.validate = function () {\n    var _this = this;\n    _super.prototype.validate.call(this);\n    if (this.xAxis && this.yAxis) {\n      this._segmentsIterator.reset();\n      this.openSegmentWrapper(this._adjustedStartIndex);\n      $iter.each(this.axisRanges.iterator(), function (range) {\n        _this.openSegmentWrapper(_this._adjustedStartIndex, range);\n      });\n      $iter.each(this._segmentsIterator.iterator(), function (segment) {\n        segment.__disabled = true;\n      });\n    }\n  };\n  /**\r\n   * [sliceData description]\r\n   *\r\n   * @todo Description\r\n   */\n  LineSeries.prototype.sliceData = function () {\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    // we need extra one item to both sides with values for line series, otherwise the line will not continue out of bounds of the chart while scrolling\n    // find first to the left\n    // TODO use iterator instead\n    for (var i = this.startIndex - 1; i >= 0; i--) {\n      var dataItem = this.dataItems.getIndex(i);\n      if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\n        startIndex = i;\n        break;\n      }\n    }\n    this._adjustedStartIndex = this.findAdjustedIndex(startIndex, [\"stroke\", \"strokeWidth\", \"strokeDasharray\", \"strokeOpacity\", \"fill\", \"fillOpacity\", \"opacity\"]);\n    // find first to the right\n    // TODO use iterator instead\n    for (var i = this.endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\n        endIndex = i + 1;\n        break;\n      }\n    }\n    this._workingStartIndex = startIndex;\n    this._workingEndIndex = endIndex;\n  };\n  /**\r\n   * @ignore\r\n   */\n  LineSeries.prototype.findAdjustedIndex = function (adjustedIndex, properties) {\n    var _this = this;\n    var propertyFields = this.propertyFields;\n    var startIndex = adjustedIndex;\n    $array.each(properties, function (property) {\n      if ($type.hasValue(propertyFields[property])) {\n        for (var i = startIndex; i >= 0; i--) {\n          var dataItem = _this.dataItems.getIndex(i);\n          if (dataItem) {\n            if ($type.hasValue(dataItem.properties[property])) {\n              if (adjustedIndex > i) {\n                adjustedIndex = i;\n              }\n              break;\n            }\n          }\n        }\n      }\n    });\n    return adjustedIndex;\n  };\n  /**\r\n   * Wraps openSegment call with iterative solution to prevent stack overflow\r\n   *\r\n   * @param openIndex  Index\r\n   * @param axisRange  Range\r\n   */\n  LineSeries.prototype.openSegmentWrapper = function (openIndex, axisRange) {\n    var params = {\n      \"index\": openIndex,\n      \"axisRange\": axisRange\n    };\n    do {\n      params = this.openSegment(params.index, params.axisRange);\n    } while (params);\n  };\n  LineSeries.prototype.getSegment = function () {\n    var segment = this._segmentsIterator.getFirst();\n    segment.series = this;\n    if (segment.isDisposed()) {\n      this.segments.removeValue(segment);\n      return this.getSegment();\n    }\n    return segment;\n  };\n  /**\r\n   * [openSegment description]\r\n   *\r\n   * @todo Description\r\n   * @param openIndex  [description]\r\n   * @param axisRange  [description]\r\n   */\n  LineSeries.prototype.openSegment = function (openIndex, axisRange) {\n    var addToClose = false;\n    var points = [];\n    openIndex = Math.min(openIndex, this.dataItems.length);\n    var endIndex = Math.min(this._workingEndIndex, this.dataItems.length);\n    this._workingEndIndex = Math.min(this._workingEndIndex, this.dataItems.length);\n    var closeIndex;\n    var propertiesChanged = false;\n    var segment = this.getSegment();\n    segment.strokeDasharray = undefined;\n    segment.__disabled = false;\n    if (axisRange) {\n      segment.parent = axisRange.contents;\n      $object.copyProperties(axisRange.contents, segment, visualProperties);\n    } else {\n      $object.copyProperties(this, segment, visualProperties);\n      segment.filters.clear();\n      segment.parent = this.segmentsContainer;\n    }\n    this.group.node.removeAttribute(\"fill\");\n    var connect = this.connect;\n    var valuesFound = false; // some flag to avoid multiple closes if no values found\n    for (var i = openIndex; i < endIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.segment = segment;\n      if (dataItem.hasProperties) {\n        // if this is first item of segment\n        if (i == openIndex) {\n          this.updateSegmentProperties(dataItem.properties, segment);\n        } else {\n          // this time we only need to know if properties changed, so we don't pass segment\n          propertiesChanged = this.updateSegmentProperties(dataItem.properties, segment, true);\n        }\n      }\n      if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\n        this.addPoints(points, dataItem, this.xField, this.yField);\n        valuesFound = true;\n      } else {\n        // if no values in first data item, go to next\n        if (i == openIndex) {\n          continue;\n        } else {\n          // stop cycle\n          if (!connect && valuesFound) {\n            closeIndex = i;\n            break;\n          }\n        }\n      }\n      closeIndex = i;\n      if (this.baseAxis instanceof DateAxis) {\n        var next = this.dataItems.getIndex(i + 1);\n        if (next && this.baseAxis.makeGap(next, dataItem)) {\n          addToClose = true;\n          break;\n        }\n      }\n      if (propertiesChanged) {\n        break;\n      }\n    }\n    return this.closeSegment(segment, points, openIndex, closeIndex, axisRange, addToClose);\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @todo Description\r\n   * @param points    [description]\r\n   * @param dataItem  [description]\r\n   * @param xField    [description]\r\n   * @param yField    [description]\r\n   * @param backwards [description]\r\n   */\n  LineSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {\n    var point = this.getPoint(dataItem, xField, yField, dataItem.workingLocations[xField], dataItem.workingLocations[yField]);\n    if (!backwards) {\n      dataItem.point = point;\n    }\n    points.push(point);\n  };\n  /**\r\n   * [closeSegment description]\r\n   *\r\n   * @todo Description\r\n   * @param segment    [description]\r\n   * @param points     [description]\r\n   * @param openIndex  [description]\r\n   * @param closeIndex [description]\r\n   * @param axisRange  [description]\r\n   */\n  LineSeries.prototype.closeSegment = function (segment, points, openIndex, closeIndex, axisRange, add) {\n    var closePoints = [];\n    if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {\n      for (var i = closeIndex; i >= openIndex; i--) {\n        var dataItem = this.dataItems.getIndex(i);\n        if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\n          // not sure, this means that open point will only be added if value is also set for this point, but maybe it's ok.\n          this.addPoints(closePoints, dataItem, this.xOpenField, this.yOpenField, true);\n        }\n      }\n    } else {\n      var baseAxis = this.baseAxis;\n      var count = points.length;\n      var xAxis = this.xAxis;\n      var yAxis = this.yAxis;\n      if (count > 0) {\n        if (baseAxis == xAxis) {\n          closePoints.push({\n            x: points[count - 1].x,\n            y: yAxis.basePoint.y\n          }); // last x\n          closePoints.push({\n            x: points[0].x,\n            y: yAxis.basePoint.y\n          }); // first x\n        } else {\n          closePoints.push({\n            x: xAxis.basePoint.x,\n            y: points[count - 1].y\n          }); // last y\n          closePoints.push({\n            x: xAxis.basePoint.x,\n            y: points[0].y\n          }); // first y\n        }\n      }\n    }\n    this.drawSegment(segment, points, closePoints);\n    if (add) {\n      closeIndex++;\n    }\n    if (closeIndex < this._workingEndIndex - 1) {\n      return {\n        \"index\": closeIndex,\n        \"axisRange\": axisRange\n      };\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Draws the line segment.\r\n   *\r\n   * @param segment     Segment\r\n   * @param points      Segment points\r\n   * @param closePoints Segment close points\r\n   */\n  LineSeries.prototype.drawSegment = function (segment, points, closePoints) {\n    segment.drawSegment(points, closePoints, this.tensionX, this.tensionY);\n  };\n  /**\r\n   * Segement will get its colors from `this.dataItem`, as thats how\r\n   * `getPropertyValue()` method works.\r\n   *\r\n   * We pass `lineSeriesDataItem.properties` as item here each time when a flag\r\n   * `hasProperties` is set to `true` on data item (this means it can contain\r\n   * some properties set).\r\n   *\r\n   * @param itemProperties  Item properties\r\n   * @param segment         Segment\r\n   * @return Properties changed?\r\n   */\n  LineSeries.prototype.updateSegmentProperties = function (itemProperties, segment, checkOnly) {\n    var changed = false;\n    $object.each(itemProperties, function (propertyName, value) {\n      // some value must be defined\n      if ($type.hasValue(value)) {\n        var currentValue = segment[propertyName];\n        var currentValueStr = void 0;\n        // current value can be Color, number, anything. So we check if it has toString, otherwise just do String().\n        // toString() will return hex if it's color. The only problem is that it will return lowercased hex and if we have uppercase in data, it will think that it changed\n        if (currentValue) {\n          if (currentValue.toString) {\n            currentValueStr = currentValue.toString();\n          } else {\n            currentValueStr = currentValue; // not doing String(currentValue) as this will make all Objects the same\n          }\n        }\n        var valueStr = void 0;\n        if (value) {\n          if (value.toString) {\n            valueStr = value.toString();\n          } else {\n            valueStr = value; // not doing String(currentValue) as this will make all Objects the same\n          }\n        }\n        if (currentValue == value || currentValueStr != undefined && valueStr != undefined && currentValueStr == valueStr) {\n          // void\n        } else {\n          if (!checkOnly) {\n            segment[propertyName] = value;\n          }\n          changed = true;\n        }\n      }\n    });\n    return changed;\n  };\n  Object.defineProperty(LineSeries.prototype, \"connect\", {\n    /**\r\n     * @return Connect?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"connect\");\n    },\n    /**\r\n     * Connect the lines over empty data points?\r\n     *\r\n     * If set to `true` the line will connect two adjacent data points by a\r\n     * straight line. Even if there are data points with missing values\r\n     * in-between.\r\n     *\r\n     * If you set this to `false`, the line will break when there are missing\r\n     * values.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#Line_series_with_gaps} for more information about this feature\r\n     * @default true\r\n     * @param value  Connect?\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"connect\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineSeries.prototype, \"tensionX\", {\n    /**\r\n     * @return Horizontal tension (0-1)\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tensionX\");\n    },\n    /**\r\n     * Horizontal tension setting of the line (0-1).\r\n     *\r\n     * Can be used to create smoothed lines. It works like this:\r\n     *\r\n     * Accepted values are in the range between 0 and 1. The biggest value (1)\r\n     * will mean that the \"tension\" is very high, so the line is maximally\r\n     * attracted to the points it connects, hence the straight line.\r\n     *\r\n     * Using smaller numbers will \"relax\" the tension, creating some curving.\r\n     *\r\n     * The smaller the tension setting, the more relaxed the line and the more\r\n     * wide the curve.\r\n     *\r\n     * This setting is for horizontal tension, meaning the curve will bend in\r\n     * such way that it never goes below or above connecting points. To enable\r\n     * vertical bending as well, use `tensionY`.\r\n     *\r\n     * IMPORTANT: line smoothing works best when data items are placed at regular\r\n     * intervals. For setups where data items are spaced erratically, enabling\r\n     * smoothing might result in awkwardly looking lines.\r\n     *\r\n     * @default 1\r\n     * @param value  Horizontal tension (0-1)\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tensionX\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineSeries.prototype, \"tensionY\", {\n    /**\r\n     * @return Vertical tension (0-1)\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tensionY\");\n    },\n    /**\r\n     * Can be used to create smoothed lines. It works like this:\r\n     *\r\n     * Accepted values are in the range between 0 and 1. The biggest value (1)\r\n     * will mean that the \"tension\" is very high, so the line is maximally\r\n     * attracted to the points it connects, hence the straight line.\r\n     *\r\n     * Using smaller numbers will \"relax\" the tension, creating some curving.\r\n     *\r\n     * The smaller the tension setting, the more relaxed the line and the more\r\n     * wide the curve.\r\n     *\r\n     * This setting is for vertical tension, meaning the curve might bend in\r\n     * such way that it will go below or above connected points.\r\n     *\r\n     * Combine this setting with `tensionX` to create beautifully looking\r\n     * smoothed line series.\r\n     *\r\n     * @default 1\r\n     * @param value  Vertical tension (0-1)\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tensionY\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates elements in related legend container, that mimics the look of this\r\n   * Series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param marker  Legend item container\r\n   */\n  LineSeries.prototype.createLegendMarker = function (marker) {\n    var _this = this;\n    var w = marker.pixelWidth;\n    var h = marker.pixelHeight;\n    marker.disposeChildren();\n    var line = marker.createChild(Line);\n    line.shouldClone = false;\n    //line.copyFrom(<any>this); coppies events which is not good\n    $object.copyProperties(this, line, visualProperties);\n    line.x2 = w;\n    line.y = h / 2;\n    line.y2 = 0.00001;\n    line.visible = true;\n    if (this.fillOpacity > 0) {\n      var fill = marker.createChild(Rectangle);\n      //fill.copyFrom(<any>this); coppies events which is not good\n      $object.copyProperties(this, fill, visualProperties);\n      fill.width = w;\n      fill.height = h;\n      fill.y = 0;\n      fill.strokeOpacity = 0;\n      fill.visible = true;\n      line.y = 0;\n    }\n    var legendDataItem = marker.dataItem;\n    legendDataItem.color = this.stroke;\n    legendDataItem.colorOrig = this.fill;\n    $iter.eachContinue(this.bullets.iterator(), function (bullet) {\n      if (bullet instanceof Bullet && !bullet.copyToLegendMarker) {\n        return false;\n      }\n      var hasLabels = false;\n      if (bullet instanceof Container) {\n        // do not copy bullets with labels\n        $iter.each(bullet.children.iterator(), function (child) {\n          if (child instanceof Label) {\n            hasLabels = true;\n            return true;\n          }\n        });\n      }\n      if (!hasLabels) {\n        var clone = bullet.clone();\n        clone.parent = marker;\n        clone.isMeasured = true;\n        clone.tooltipText = undefined;\n        clone.x = w / 2;\n        if (_this.fillOpacity > 0) {\n          clone.y = 0;\n        } else {\n          clone.y = h / 2;\n        }\n        clone.visible = true;\n        // otherwise will not transit to color after hiding\n        if (!$type.hasValue(clone.fill)) {\n          clone.fill = _this.fill;\n        }\n        if (!$type.hasValue(clone.stroke)) {\n          clone.stroke = _this.stroke;\n        }\n        return false;\n      }\n    });\n  };\n  /**\r\n   * @ignore\r\n   */\n  LineSeries.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n    this.segments.clear();\n  };\n  Object.defineProperty(LineSeries.prototype, \"autoGapCount\", {\n    /**\r\n     * @return Gap count\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"autoGapCount\");\n    },\n    /**\r\n     * If `connect = false` and distance between two data points is bigger\r\n     * than `baseInterval * autoGapCount`, a line will break automatically.\r\n     *\r\n     * @since 4.2.4\r\n     * @param  value  Gap count\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"autoGapCount\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineSeries.prototype, \"smoothing\", {\n    /**\r\n     * @return Smoothing algorithm\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"smoothing\");\n    },\n    /**\r\n     * Smoothing algorithm to be used for lines.\r\n     *\r\n     * Available options: `\"bezier\"` (default), `\"monotoneX\"`, and `\"monotoneY\"`.\r\n     *\r\n     * Monotone options are best suited for data with irregular intervals. Use `\"monotoneX\"` for\r\n     * horizontal lines, and `\"monotoneY\"` vertical ones.\r\n     *\r\n     * NOTE: Both \"monotone\" algorithms will ignore `tensionX` and `tensionY` settings.\r\n     *\r\n     * @since 4.10.0\r\n     * @param  value  Smoothing algorithm\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"smoothing\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LineSeries;\n}(XYSeries);\nexport { LineSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"LineSeries\"] = LineSeries;\nregistry.registeredClasses[\"LineSeriesDataItem\"] = LineSeriesDataItem;","map":{"version":3,"names":["XYSeries","XYSeriesDataItem","visualProperties","Container","ListTemplate","ListDisposer","LineSeriesSegment","ValueAxis","DateAxis","DurationAxis","CategoryAxis","registry","Line","Label","Rectangle","$iter","$object","$type","$array","Bullet","LineSeriesDataItem","_super","__extends","_this","call","className","LineSeries","minDistance","segments","createSegment","template","applyOnClones","_disposers","push","_segmentsIterator","ListIterator","create","createNewItems","strokeOpacity","fillOpacity","connect","tensionX","tensionY","autoGapCount","smoothing","segmentsContainer","mainContainer","createChild","isMeasured","bulletsContainer","toFront","applyTheme","prototype","applyInternalDefaults","hasValue","readerTitle","language","translate","createDataItem","setInitialWorkingValues","dataItem","yAxis","_yAxis","get","xAxis","_xAxis","appeared","visible","previousDataItem","dataItems","getIndex","index","component","baseAxis","initialY","minZoomed","values","workingValue","setWorkingValue","valueY","value","setWorkingLocation","locations","dateX","valueX","initialX","dateY","categoryX","categoryY","updateLegendValue","notRange","segment","tooltipColorSource","validate","reset","openSegmentWrapper","_adjustedStartIndex","each","axisRanges","iterator","range","__disabled","sliceData","startIndex","endIndex","i","_xValueFields","_yValueFields","findAdjustedIndex","len","length","_workingStartIndex","_workingEndIndex","adjustedIndex","properties","propertyFields","property","openIndex","axisRange","params","openSegment","getSegment","getFirst","series","isDisposed","removeValue","addToClose","points","Math","min","closeIndex","propertiesChanged","strokeDasharray","undefined","parent","contents","copyProperties","filters","clear","group","node","removeAttribute","valuesFound","hasProperties","updateSegmentProperties","addPoints","xField","yField","next","makeGap","closeSegment","backwards","point","getPoint","workingLocations","add","closePoints","dataFields","_xOpenField","_yOpenField","stacked","xOpenField","yOpenField","count","x","y","basePoint","drawSegment","itemProperties","checkOnly","changed","propertyName","currentValue","currentValueStr","toString","valueStr","Object","defineProperty","getPropertyValue","set","setPropertyValue","invalidate","createLegendMarker","marker","w","pixelWidth","h","pixelHeight","disposeChildren","line","shouldClone","x2","y2","fill","width","height","legendDataItem","color","stroke","colorOrig","eachContinue","bullets","bullet","copyToLegendMarker","hasLabels","children","child","clone","tooltipText","disposeData","registeredClasses"],"sources":["../../../../../src/.internal/charts/series/LineSeries.ts"],"sourcesContent":["/**\r\n * Line series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { XYSeries, XYSeriesDataItem, IXYSeriesProperties, IXYSeriesDataFields, IXYSeriesAdapters, IXYSeriesEvents } from \"./XYSeries\";\r\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\r\nimport { Container } from \"../../core/Container\";\r\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { LineSeriesSegment } from \"./LineSeriesSegment\";\r\nimport { Axis, AxisDataItem } from \"../axes/Axis\";\r\nimport { ValueAxis } from \"../axes/ValueAxis\";\r\nimport { DateAxis } from \"../axes/DateAxis\";\r\nimport { DurationAxis } from \"../axes/DurationAxis\";\r\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Line } from \"../../core/elements/Line\";\r\nimport { Label } from \"../../core/elements/Label\";\r\nimport { Rectangle } from \"../../core/elements/Rectangle\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport { LegendDataItem } from \"../Legend\";\r\nimport { Bullet } from \"../elements/Bullet\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[LineSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class LineSeriesDataItem extends XYSeriesDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: LineSeries;\r\n\r\n\t/**\r\n\t * Point of line series data item\r\n\t */\r\n\tpublic point: IPoint;\r\n\r\n\t/**\r\n\t * A reference to a segment object, used for getting proper colors for tooltips\r\n\t */\r\n\tpublic segment: LineSeriesSegment;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"LineSeriesDataItem\";\r\n\t}\r\n\r\n\t// @todo: minimums/maximums\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[LineSeries]].\r\n */\r\nexport interface ILineSeriesDataFields extends IXYSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[LineSeries]].\r\n */\r\nexport interface ILineSeriesProperties extends IXYSeriesProperties {\r\n\r\n\t/**\r\n\t * Horizontal tension setting of the line (0-1).\r\n\t *\r\n\t * Used for smoothed lines.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\ttensionX?: number;\r\n\r\n\t/**\r\n\t * Vertical tension setting of the line (0-1).\r\n\t *\r\n\t * Used for smoothed lines.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\ttensionY?: number;\r\n\r\n\t/**\r\n\t * Connect the lines over empty data points?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tconnect?: boolean;\r\n\r\n\t/**\r\n\t * If `connect = false` and distance between two data points is bigger\r\n\t * than `baseInterval * autoGapCount`, a line will break automatically.\r\n\t *\r\n\t * @default 1.1\r\n\t */\r\n\tautoGapCount?: number;\r\n\r\n\t/**\r\n\t * Smoothing algorythm to use for the line.\r\n\t *\r\n\t * @since 4.10.0\r\n\t */\r\n\tsmoothing: \"bezier\" | \"monotoneX\" | \"monotoneY\";\r\n}\r\n\r\n/**\r\n * Defines events for [[LineSeries]].\r\n */\r\nexport interface ILineSeriesEvents extends IXYSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[LineSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILineSeriesAdapters extends IXYSeriesAdapters, ILineSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines [[Series]] for a line graph.\r\n *\r\n * @see {@link ILineSeriesEvents} for a list of available Events\r\n * @see {@link ILineSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\r\nexport class LineSeries extends XYSeries {\r\n\r\n\t/**\r\n\t * Defines the type of data fields used for the series.\r\n\t */\r\n\tpublic _dataFields: ILineSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILineSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ILineSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILineSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: LineSeriesDataItem;\r\n\r\n\t/**\r\n\t * A list of line series segments.\r\n\t *\r\n\t * Segments are used in two cases:\r\n\t *\r\n\t * * When we want to change the appearance of a part of the line series;\r\n\t * * When we have an axis range.\r\n\t */\r\n\tpublic segments: ListTemplate<this[\"_segment\"]>;\r\n\r\n\t/**\r\n\t * Defines type for segment.\r\n\t */\r\n\tpublic _segment: LineSeriesSegment;\r\n\r\n\t/**\r\n\t * A container for segment elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic segmentsContainer: Container;\r\n\r\n\t/**\r\n\t * Minimum distance in pixels between two adjacent points.\r\n\t *\r\n\t * If the distance is less than this setting, a point is skipped.\r\n\t *\r\n\t * This allows acceptable performance with huge amounts of data points.\r\n\t *\r\n\t * @default 0.5\r\n\t */\r\n\tpublic minDistance: number = 0.5;\r\n\r\n\t/**\r\n\t * Iterator for segments.\r\n\t */\r\n\tprotected _segmentsIterator: $iter.ListIterator<this[\"_segment\"]>;\r\n\r\n\tprotected _adjustedStartIndex: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.segments = new ListTemplate<LineSeriesSegment>(this.createSegment());\r\n\t\tthis.segments.template.applyOnClones = true;\r\n\r\n\t\tthis._disposers.push(new ListDisposer(this.segments));\r\n\t\tthis._disposers.push(this.segments.template);\r\n\r\n\t\tthis._segmentsIterator = new $iter.ListIterator<LineSeriesSegment>(this.segments, () => this.segments.create());\r\n\t\tthis._segmentsIterator.createNewItems = true;\r\n\r\n\t\tthis.className = \"LineSeries\";\r\n\r\n\t\tthis.strokeOpacity = 1;\r\n\t\tthis.fillOpacity = 0;\r\n\r\n\t\tthis.connect = true;\r\n\r\n\t\tthis.tensionX = 1;\r\n\t\tthis.tensionY = 1;\r\n\r\n\t\tthis.autoGapCount = 1.1;\r\n\r\n\t\tthis.smoothing = \"bezier\";\r\n\r\n\r\n\t\tthis.segmentsContainer = this.mainContainer.createChild(Container);\r\n\t\tthis.segmentsContainer.isMeasured = false;\r\n\r\n\t\t// line series might have multiple segments and it has a separate sprite for fill and stroke for each segment. So we need to observe all the changes on series and set them on the segments\r\n\t\t// todo: we need list here, otherwise everything will be redrawn event on change of properties like tooltipX or similar.\r\n\t\t// this.addEventListener(SpriteEvent.PROPERTY_CHANGED, this.validateDataElements, false, this);\r\n\r\n\t\tthis.bulletsContainer.toFront();\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\t\tif (!$type.hasValue(this.readerTitle)) {\r\n\t\t\tthis.readerTitle = this.language.translate(\"Line Series\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected createSegment(): this[\"_segment\"] {\r\n\t\treturn new LineSeriesSegment();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new LineSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Inits data item's working values.\r\n\t *\r\n\t * @param dataItem  Data item\r\n\t * @param index     Data item's index\r\n\t */\r\n\r\n\tprotected setInitialWorkingValues(dataItem: this[\"_dataItem\"]): void {\r\n\t\t// this makes data items animate when added\r\n\r\n\t\tlet yAxis: Axis = this._yAxis.get();\r\n\t\tlet xAxis: Axis = this._xAxis.get();\r\n\r\n\t\tif (this.appeared && this.visible) {\r\n\r\n\t\t\tlet previousDataItem: XYSeriesDataItem = this.dataItems.getIndex(dataItem.index - 1);\r\n\r\n\t\t\tdataItem.component = this; // as these values are set before, we don't know component yet\r\n\r\n\t\t\tif (this.baseAxis == xAxis) {\r\n\t\t\t\tif (yAxis instanceof ValueAxis) {\r\n\t\t\t\t\tlet initialY: number = yAxis.minZoomed;\r\n\t\t\t\t\tif (previousDataItem) {\r\n\t\t\t\t\t\tinitialY = previousDataItem.values[\"valueY\"].workingValue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// this makes line animate from previous point to newly added point\r\n\t\t\t\t\tdataItem.setWorkingValue(\"valueY\", initialY, 0);\r\n\t\t\t\t\tdataItem.setWorkingValue(\"valueY\", dataItem.values.valueY.value);\r\n\r\n\t\t\t\t\tif (xAxis instanceof DateAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX - 1, 0); // instantly move it to previous\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX); // animate to it's location\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (xAxis instanceof DurationAxis) {\r\n\t\t\t\t\t\tif (previousDataItem) {\r\n\t\t\t\t\t\t\tlet value = dataItem.valueX;\r\n\t\t\t\t\t\t\tdataItem.setWorkingValue(\"valueX\", previousDataItem.valueX, 0); // instantly move it to previous\r\n\t\t\t\t\t\t\tdataItem.setWorkingValue(\"valueX\", value); // animate to new value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.baseAxis == yAxis) {\r\n\t\t\t\tif (xAxis instanceof ValueAxis) {\r\n\t\t\t\t\tlet initialX: number = xAxis.minZoomed;\r\n\t\t\t\t\tif (previousDataItem) {\r\n\t\t\t\t\t\tinitialX = previousDataItem.values[\"valueX\"].workingValue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdataItem.setWorkingValue(\"valueX\", initialX, 0);\r\n\t\t\t\t\tdataItem.setWorkingValue(\"valueX\", dataItem.values.valueX.value);\r\n\r\n\t\t\t\t\tif (yAxis instanceof DateAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateX - 1, 0); // instantly move it to previous\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateY); // animate to it's location\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (yAxis instanceof DurationAxis) {\r\n\t\t\t\t\t\tif (previousDataItem) {\r\n\t\t\t\t\t\t\tlet value = dataItem.valueY;\r\n\t\t\t\t\t\t\tdataItem.setWorkingValue(\"valueY\", previousDataItem.valueY, 0); // instantly move it to previous\r\n\t\t\t\t\t\t\tdataItem.setWorkingValue(\"valueY\", value); // animate to new value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.baseAxis == xAxis) {\r\n\t\t\t\tif (yAxis instanceof ValueAxis) {\r\n\t\t\t\t\tif (xAxis instanceof DateAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateX\", dataItem.locations.dateX);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (xAxis instanceof CategoryAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"categoryX\", dataItem.locations.categoryX);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.baseAxis == yAxis) {\r\n\t\t\t\tif (xAxis instanceof ValueAxis) {\r\n\t\t\t\t\tif (yAxis instanceof DateAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"dateY\", dataItem.locations.dateY);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (yAxis instanceof CategoryAxis) {\r\n\t\t\t\t\t\tdataItem.setWorkingLocation(\"categoryY\", dataItem.locations.categoryY);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Updates corresponding legend data item with current values.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic updateLegendValue(dataItem?: this[\"_dataItem\"], notRange?: boolean) {\r\n\t\tsuper.updateLegendValue(dataItem, notRange);\r\n\t\t//This is hack to save some methos, used to set tooltip color source only\r\n\t\tif (dataItem && dataItem.segment) {\r\n\t\t\tthis.tooltipColorSource = dataItem.segment;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the whole series, effectively causing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tif (this.xAxis && this.yAxis) {\r\n\t\t\tthis._segmentsIterator.reset();\r\n\r\n\t\t\tthis.openSegmentWrapper(this._adjustedStartIndex);\r\n\r\n\t\t\t$iter.each(this.axisRanges.iterator(), (range) => {\r\n\t\t\t\tthis.openSegmentWrapper(this._adjustedStartIndex, range);\r\n\t\t\t});\r\n\r\n\t\t\t$iter.each(this._segmentsIterator.iterator(), (segment) => {\r\n\t\t\t\tsegment.__disabled = true;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [sliceData description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected sliceData(): void {\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\t// we need extra one item to both sides with values for line series, otherwise the line will not continue out of bounds of the chart while scrolling\r\n\t\t// find first to the left\r\n\t\t// TODO use iterator instead\r\n\t\tfor (let i = this.startIndex - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tif (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\r\n\t\t\t\tstartIndex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._adjustedStartIndex = this.findAdjustedIndex(startIndex, [\"stroke\", \"strokeWidth\", \"strokeDasharray\", \"strokeOpacity\", \"fill\", \"fillOpacity\", \"opacity\"]);\r\n\r\n\t\t// find first to the right\r\n\t\t// TODO use iterator instead\r\n\t\tfor (let i = this.endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tif (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\r\n\t\t\t\tendIndex = i + 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._workingStartIndex = startIndex;\r\n\t\tthis._workingEndIndex = endIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected findAdjustedIndex(adjustedIndex: number, properties: string[]): number {\r\n\t\tlet propertyFields: any = this.propertyFields;\r\n\t\tlet startIndex = adjustedIndex;\r\n\r\n\t\t$array.each(properties, (property) => {\r\n\t\t\tif ($type.hasValue(propertyFields[property])) {\r\n\t\t\t\tfor (let i = startIndex; i >= 0; i--) {\r\n\t\t\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif (dataItem) {\r\n\t\t\t\t\t\tif ($type.hasValue(dataItem.properties[property])) {\r\n\t\t\t\t\t\t\tif (adjustedIndex > i) {\r\n\t\t\t\t\t\t\t\tadjustedIndex = i;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn adjustedIndex;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Wraps openSegment call with iterative solution to prevent stack overflow\r\n\t *\r\n\t * @param openIndex  Index\r\n\t * @param axisRange  Range\r\n\t */\r\n\tprotected openSegmentWrapper(openIndex: number, axisRange?: AxisDataItem): void {\r\n\t\tlet params = {\r\n\t\t\t\"index\": openIndex,\r\n\t\t\t\"axisRange\": axisRange\r\n\t\t};\r\n\t\tdo {\r\n\t\t\tparams = this.openSegment(params.index, params.axisRange);\r\n\t\t} while (params)\r\n\t}\r\n\r\n\r\n\tprotected getSegment(): LineSeriesSegment {\r\n\t\tlet segment = this._segmentsIterator.getFirst();\r\n\t\tsegment.series = this;\r\n\t\tif (segment.isDisposed()) {\r\n\t\t\tthis.segments.removeValue(segment);\r\n\t\t\treturn this.getSegment();\r\n\t\t}\r\n\t\treturn segment;\r\n\t}\r\n\r\n\t/**\r\n\t * [openSegment description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param openIndex  [description]\r\n\t * @param axisRange  [description]\r\n\t */\r\n\tprotected openSegment(openIndex: number, axisRange?: AxisDataItem): { \"index\": number, \"axisRange\": AxisDataItem } {\r\n\t\tlet addToClose = false;\r\n\t\tlet points: IPoint[] = [];\r\n\t\topenIndex = Math.min(openIndex, this.dataItems.length);\r\n\t\tlet endIndex: number = Math.min(this._workingEndIndex, this.dataItems.length);\r\n\t\tthis._workingEndIndex = Math.min(this._workingEndIndex, this.dataItems.length);\r\n\r\n\t\tlet closeIndex: number;\r\n\t\tlet propertiesChanged: boolean = false;\r\n\r\n\t\tlet segment: LineSeriesSegment = this.getSegment();\r\n\t\tsegment.strokeDasharray = undefined;\r\n\t\tsegment.__disabled = false;\r\n\r\n\t\tif (axisRange) {\r\n\t\t\tsegment.parent = axisRange.contents;\r\n\t\t\t$object.copyProperties(axisRange.contents, segment, visualProperties);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$object.copyProperties(this, segment, visualProperties);\r\n\t\t\tsegment.filters.clear();\r\n\t\t\tsegment.parent = this.segmentsContainer;\r\n\t\t}\r\n\r\n\t\tthis.group.node.removeAttribute(\"fill\");\r\n\r\n\t\tlet connect: boolean = this.connect;\r\n\t\tlet valuesFound: boolean = false; // some flag to avoid multiple closes if no values found\r\n\r\n\t\tfor (let i: number = openIndex; i < endIndex; i++) {\r\n\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.segment = segment;\r\n\r\n\t\t\tif (dataItem.hasProperties) {\r\n\t\t\t\t// if this is first item of segment\r\n\t\t\t\tif (i == openIndex) {\r\n\t\t\t\t\tthis.updateSegmentProperties(dataItem.properties, segment);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// this time we only need to know if properties changed, so we don't pass segment\r\n\t\t\t\t\tpropertiesChanged = this.updateSegmentProperties(dataItem.properties, segment, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {\r\n\t\t\t\tthis.addPoints(points, dataItem, this.xField, this.yField);\r\n\t\t\t\tvaluesFound = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// if no values in first data item, go to next\r\n\t\t\t\tif (i == openIndex) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// stop cycle\r\n\t\t\t\t\tif (!connect && valuesFound) {\r\n\t\t\t\t\t\tcloseIndex = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcloseIndex = i;\r\n\r\n\t\t\tif (this.baseAxis instanceof DateAxis) {\r\n\t\t\t\tlet next = this.dataItems.getIndex(i + 1)\r\n\t\t\t\tif (next && this.baseAxis.makeGap(next, dataItem)) {\r\n\t\t\t\t\taddToClose = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (propertiesChanged) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.closeSegment(segment, points, openIndex, closeIndex, axisRange, addToClose);\r\n\t}\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param points    [description]\r\n\t * @param dataItem  [description]\r\n\t * @param xField    [description]\r\n\t * @param yField    [description]\r\n\t * @param backwards [description]\r\n\t */\r\n\tprotected addPoints(points: IPoint[], dataItem: this[\"_dataItem\"], xField: string, yField: string, backwards?: boolean) {\r\n\t\tlet point = this.getPoint(dataItem, xField, yField, dataItem.workingLocations[xField], dataItem.workingLocations[yField]);\r\n\t\tif (!backwards) {\r\n\t\t\tdataItem.point = point;\r\n\t\t}\r\n\t\tpoints.push(point);\r\n\t}\r\n\r\n\t/**\r\n\t * [closeSegment description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param segment    [description]\r\n\t * @param points     [description]\r\n\t * @param openIndex  [description]\r\n\t * @param closeIndex [description]\r\n\t * @param axisRange  [description]\r\n\t */\r\n\tprotected closeSegment(segment: LineSeriesSegment, points: IPoint[], openIndex: number, closeIndex: number, axisRange?: AxisDataItem, add?: boolean) {\r\n\t\tlet closePoints: IPoint[] = [];\r\n\r\n\t\tif (this.dataFields[<keyof this[\"_dataFields\"]>this._xOpenField] ||\r\n\t\t\tthis.dataFields[<keyof this[\"_dataFields\"]>this._yOpenField] ||\r\n\t\t\tthis.stacked) {\r\n\t\t\tfor (let i: number = closeIndex; i >= openIndex; i--) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) { // not sure, this means that open point will only be added if value is also set for this point, but maybe it's ok.\r\n\t\t\t\t\tthis.addPoints(closePoints, dataItem, this.xOpenField, this.yOpenField, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet baseAxis: Axis = this.baseAxis;\r\n\t\t\tlet count: number = points.length;\r\n\t\t\tlet xAxis: Axis = this.xAxis;\r\n\t\t\tlet yAxis: Axis = this.yAxis;\r\n\t\t\tif (count > 0) {\r\n\t\t\t\tif (baseAxis == xAxis) {\r\n\t\t\t\t\tclosePoints.push({ x: points[count - 1].x, y: yAxis.basePoint.y }); // last x\r\n\t\t\t\t\tclosePoints.push({ x: points[0].x, y: yAxis.basePoint.y }); // first x\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tclosePoints.push({ x: xAxis.basePoint.x, y: points[count - 1].y }); // last y\r\n\t\t\t\t\tclosePoints.push({ x: xAxis.basePoint.x, y: points[0].y }); // first y\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.drawSegment(segment, points, closePoints);\r\n\r\n\t\tif (add) {\r\n\t\t\tcloseIndex++;\r\n\t\t}\r\n\r\n\t\tif (closeIndex < this._workingEndIndex - 1) {\r\n\t\t\treturn { \"index\": closeIndex, \"axisRange\": axisRange };\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the line segment.\r\n\t *\r\n\t * @param segment     Segment\r\n\t * @param points      Segment points\r\n\t * @param closePoints Segment close points\r\n\t */\r\n\tprotected drawSegment(segment: LineSeriesSegment, points: IPoint[], closePoints: IPoint[]): void {\r\n\t\tsegment.drawSegment(points, closePoints, this.tensionX, this.tensionY);\r\n\t}\r\n\r\n\t/**\r\n\t * Segement will get its colors from `this.dataItem`, as thats how\r\n\t * `getPropertyValue()` method works.\r\n\t *\r\n\t * We pass `lineSeriesDataItem.properties` as item here each time when a flag\r\n\t * `hasProperties` is set to `true` on data item (this means it can contain\r\n\t * some properties set).\r\n\t *\r\n\t * @param itemProperties  Item properties\r\n\t * @param segment         Segment\r\n\t * @return Properties changed?\r\n\t */\r\n\tprotected updateSegmentProperties(itemProperties: { [index: string]: any }, segment: LineSeriesSegment, checkOnly?: boolean): boolean {\r\n\t\tlet changed: boolean = false;\r\n\r\n\t\t$object.each(itemProperties, (propertyName, value) => {\r\n\t\t\t// some value must be defined\r\n\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\tlet currentValue = (<any>segment)[propertyName];\r\n\t\t\t\tlet currentValueStr: string;\r\n\t\t\t\t// current value can be Color, number, anything. So we check if it has toString, otherwise just do String().\r\n\t\t\t\t// toString() will return hex if it's color. The only problem is that it will return lowercased hex and if we have uppercase in data, it will think that it changed\r\n\t\t\t\tif (currentValue) {\r\n\t\t\t\t\tif (currentValue.toString) {\r\n\t\t\t\t\t\tcurrentValueStr = currentValue.toString();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcurrentValueStr = currentValue; // not doing String(currentValue) as this will make all Objects the same\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tlet valueStr: string;\r\n\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tif (value.toString) {\r\n\t\t\t\t\t\tvalueStr = value.toString();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvalueStr = value;  // not doing String(currentValue) as this will make all Objects the same\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == value || (currentValueStr != undefined && valueStr != undefined && currentValueStr == valueStr)) {\r\n\t\t\t\t\t// void\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (!checkOnly) {\r\n\t\t\t\t\t\t(<any>segment)[propertyName] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Connect the lines over empty data points?\r\n\t *\r\n\t * If set to `true` the line will connect two adjacent data points by a\r\n\t * straight line. Even if there are data points with missing values\r\n\t * in-between.\r\n\t *\r\n\t * If you set this to `false`, the line will break when there are missing\r\n\t * values.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#Line_series_with_gaps} for more information about this feature\r\n\t * @default true\r\n\t * @param value  Connect?\r\n\t */\r\n\tpublic set connect(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"connect\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Connect?\r\n\t */\r\n\tpublic get connect(): boolean {\r\n\t\treturn this.getPropertyValue(\"connect\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal tension setting of the line (0-1).\r\n\t *\r\n\t * Can be used to create smoothed lines. It works like this:\r\n\t *\r\n\t * Accepted values are in the range between 0 and 1. The biggest value (1)\r\n\t * will mean that the \"tension\" is very high, so the line is maximally\r\n\t * attracted to the points it connects, hence the straight line.\r\n\t *\r\n\t * Using smaller numbers will \"relax\" the tension, creating some curving.\r\n\t *\r\n\t * The smaller the tension setting, the more relaxed the line and the more\r\n\t * wide the curve.\r\n\t *\r\n\t * This setting is for horizontal tension, meaning the curve will bend in\r\n\t * such way that it never goes below or above connecting points. To enable\r\n\t * vertical bending as well, use `tensionY`.\r\n\t *\r\n\t * IMPORTANT: line smoothing works best when data items are placed at regular\r\n\t * intervals. For setups where data items are spaced erratically, enabling\r\n\t * smoothing might result in awkwardly looking lines.\r\n\t *\r\n\t * @default 1\r\n\t * @param value  Horizontal tension (0-1)\r\n\t */\r\n\tpublic set tensionX(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionX\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Horizontal tension (0-1)\r\n\t */\r\n\tpublic get tensionX(): number {\r\n\t\treturn this.getPropertyValue(\"tensionX\");\r\n\t}\r\n\r\n\t/**\r\n\t * Can be used to create smoothed lines. It works like this:\r\n\t *\r\n\t * Accepted values are in the range between 0 and 1. The biggest value (1)\r\n\t * will mean that the \"tension\" is very high, so the line is maximally\r\n\t * attracted to the points it connects, hence the straight line.\r\n\t *\r\n\t * Using smaller numbers will \"relax\" the tension, creating some curving.\r\n\t *\r\n\t * The smaller the tension setting, the more relaxed the line and the more\r\n\t * wide the curve.\r\n\t *\r\n\t * This setting is for vertical tension, meaning the curve might bend in\r\n\t * such way that it will go below or above connected points.\r\n\t *\r\n\t * Combine this setting with `tensionX` to create beautifully looking\r\n\t * smoothed line series.\r\n\t *\r\n\t * @default 1\r\n\t * @param value  Vertical tension (0-1)\r\n\t */\r\n\tpublic set tensionY(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionY\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Vertical tension (0-1)\r\n\t */\r\n\tpublic get tensionY(): number {\r\n\t\treturn this.getPropertyValue(\"tensionY\");\r\n\t}\r\n\r\n\t/**\r\n\t * Creates elements in related legend container, that mimics the look of this\r\n\t * Series.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param marker  Legend item container\r\n\t */\r\n\tpublic createLegendMarker(marker: Container): void {\r\n\r\n\t\tlet w: number = marker.pixelWidth;\r\n\t\tlet h: number = marker.pixelHeight;\r\n\r\n\t\tmarker.disposeChildren();\r\n\r\n\t\tlet line: Line = marker.createChild(Line);\r\n\t\tline.shouldClone = false;\r\n\t\t//line.copyFrom(<any>this); coppies events which is not good\r\n\t\t$object.copyProperties(this, line, visualProperties);\r\n\r\n\t\tline.x2 = w;\r\n\t\tline.y = h / 2;\r\n\t\tline.y2 = 0.00001;\r\n\t\tline.visible = true;\r\n\r\n\t\tif (this.fillOpacity > 0) {\r\n\t\t\tlet fill: Rectangle = marker.createChild(Rectangle);\r\n\t\t\t//fill.copyFrom(<any>this); coppies events which is not good\r\n\t\t\t$object.copyProperties(this, fill, visualProperties);\r\n\t\t\tfill.width = w;\r\n\t\t\tfill.height = h;\r\n\t\t\tfill.y = 0;\r\n\t\t\tfill.strokeOpacity = 0;\r\n\t\t\tfill.visible = true;\r\n\r\n\t\t\tline.y = 0;\r\n\t\t}\r\n\r\n\t\tlet legendDataItem = <LegendDataItem>marker.dataItem;\r\n\t\tlegendDataItem.color = this.stroke;\r\n\t\tlegendDataItem.colorOrig = this.fill;\r\n\r\n\t\t$iter.eachContinue(this.bullets.iterator(), (bullet) => {\r\n\r\n\t\t\tif ((bullet instanceof Bullet) && !bullet.copyToLegendMarker) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tlet hasLabels: boolean = false;\r\n\r\n\t\t\tif (bullet instanceof Container) {\r\n\t\t\t\t// do not copy bullets with labels\r\n\r\n\t\t\t\t$iter.each(bullet.children.iterator(), (child) => {\r\n\t\t\t\t\tif (child instanceof Label) {\r\n\t\t\t\t\t\thasLabels = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (!hasLabels) {\r\n\t\t\t\tlet clone: Sprite = <Sprite>bullet.clone();\r\n\t\t\t\tclone.parent = marker;\r\n\t\t\t\tclone.isMeasured = true;\r\n\t\t\t\tclone.tooltipText = undefined;\r\n\t\t\t\tclone.x = w / 2;\r\n\t\t\t\tif (this.fillOpacity > 0) {\r\n\t\t\t\t\tclone.y = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tclone.y = h / 2;\r\n\t\t\t\t}\r\n\t\t\t\tclone.visible = true;\r\n\r\n\t\t\t\t// otherwise will not transit to color after hiding\r\n\t\t\t\tif (!$type.hasValue(clone.fill)) {\r\n\t\t\t\t\tclone.fill = this.fill;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!$type.hasValue(clone.stroke)) {\r\n\t\t\t\t\tclone.stroke = this.stroke;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tsuper.disposeData();\r\n\t\tthis.segments.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * If `connect = false` and distance between two data points is bigger\r\n\t * than `baseInterval * autoGapCount`, a line will break automatically.\r\n\t *\r\n\t * @since 4.2.4\r\n\t * @param  value  Gap count\r\n\t */\r\n\tpublic set autoGapCount(value: number) {\r\n\t\tthis.setPropertyValue(\"autoGapCount\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Gap count\r\n\t */\r\n\tpublic get autoGapCount(): number {\r\n\t\treturn this.getPropertyValue(\"autoGapCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * Smoothing algorithm to be used for lines.\r\n\t *\r\n\t * Available options: `\"bezier\"` (default), `\"monotoneX\"`, and `\"monotoneY\"`.\r\n\t *\r\n\t * Monotone options are best suited for data with irregular intervals. Use `\"monotoneX\"` for\r\n\t * horizontal lines, and `\"monotoneY\"` vertical ones.\r\n\t *\r\n\t * NOTE: Both \"monotone\" algorithms will ignore `tensionX` and `tensionY` settings.\r\n\t *\r\n\t * @since 4.10.0\r\n\t * @param  value  Smoothing algorithm\r\n\t */\r\n\tpublic set smoothing(value: \"bezier\" | \"monotoneX\" | \"monotoneY\") {\r\n\t\tthis.setPropertyValue(\"smoothing\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Smoothing algorithm\r\n\t */\r\n\tpublic get smoothing(): \"bezier\" | \"monotoneX\" | \"monotoneY\" {\r\n\t\treturn this.getPropertyValue(\"smoothing\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"LineSeries\"] = LineSeries;\r\nregistry.registeredClasses[\"LineSeriesDataItem\"] = LineSeriesDataItem;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}