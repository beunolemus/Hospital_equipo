{"ast":null,"code":"import _toConsumableArray from \"C:/Users/brnol/Documents/Hospital/Hospital_equipo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"C:/Users/brnol/Documents/Hospital/Hospital_equipo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _typeof from \"C:/Users/brnol/Documents/Hospital/Hospital_equipo/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nvar _errorMessages;\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.from-code-point.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.repeat.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.to-json.js\";\n/*!\n  * message-compiler v9.10.1\n  * (c) 2024 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nvar LOCATION_STUB = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\nfunction createPosition(line, column, offset) {\n  return {\n    line: line,\n    column: column,\n    offset: offset\n  };\n}\nfunction createLocation(start, end, source) {\n  var loc = {\n    start: start,\n    end: end\n  };\n  if (source != null) {\n    loc.source = source;\n  }\n  return loc;\n}\n\n/**\n * Original Utilities\n * written by kazuya kawaguchi\n */\nvar RE_ARGS = /\\{([0-9a-zA-Z]+)\\}/g;\n/* eslint-disable */\nfunction format(message) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (args.length === 1 && isObject(args[0])) {\n    args = args[0];\n  }\n  if (!args || !args.hasOwnProperty) {\n    args = {};\n  }\n  return message.replace(RE_ARGS, function (match, identifier) {\n    return args.hasOwnProperty(identifier) ? args[identifier] : '';\n  });\n}\nvar assign = Object.assign;\nvar isString = function isString(val) {\n  return typeof val === 'string';\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar isObject = function isObject(val) {\n  return val !== null && _typeof(val) === 'object';\n};\nfunction join(items) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return items.reduce(function (str, item, index) {\n    return index === 0 ? str + item : str + separator + item;\n  }, '');\n}\nvar CompileErrorCodes = {\n  // tokenizer error codes\n  EXPECTED_TOKEN: 1,\n  INVALID_TOKEN_IN_PLACEHOLDER: 2,\n  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n  UNKNOWN_ESCAPE_SEQUENCE: 4,\n  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n  UNBALANCED_CLOSING_BRACE: 6,\n  UNTERMINATED_CLOSING_BRACE: 7,\n  EMPTY_PLACEHOLDER: 8,\n  NOT_ALLOW_NEST_PLACEHOLDER: 9,\n  INVALID_LINKED_FORMAT: 10,\n  // parser error codes\n  MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n  UNEXPECTED_EMPTY_LINKED_KEY: 13,\n  UNEXPECTED_LEXICAL_ANALYSIS: 14,\n  // generator error codes\n  UNHANDLED_CODEGEN_NODE_TYPE: 15,\n  // minifier error codes\n  UNHANDLED_MINIFIER_NODE_TYPE: 16,\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__: 17\n};\n/** @internal */\nvar errorMessages = (_errorMessages = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_errorMessages, CompileErrorCodes.EXPECTED_TOKEN, \"Expected token: '{0}'\"), CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, \"Invalid token in placeholder: '{0}'\"), CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, \"Unterminated single quote in placeholder\"), CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, \"Unknown escape sequence: \\\\{0}\"), CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, \"Invalid unicode escape sequence: {0}\"), CompileErrorCodes.UNBALANCED_CLOSING_BRACE, \"Unbalanced closing brace\"), CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, \"Unterminated closing brace\"), CompileErrorCodes.EMPTY_PLACEHOLDER, \"Empty placeholder\"), CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, \"Not allowed nest placeholder\"), CompileErrorCodes.INVALID_LINKED_FORMAT, \"Invalid linked format\"), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_errorMessages, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, \"Plural must have messages\"), CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, \"Unexpected empty linked modifier\"), CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, \"Unexpected empty linked key\"), CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, \"Unexpected lexical analysis in token: '{0}'\"), CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, \"unhandled codegen node type: '{0}'\"), CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, \"unhandled mimifier node type: '{0}'\"));\nfunction createCompileError(code, loc) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var domain = options.domain,\n    messages = options.messages,\n    args = options.args;\n  var msg = format.apply(void 0, [(messages || errorMessages)[code] || ''].concat(_toConsumableArray(args || [])));\n  var error = new SyntaxError(String(msg));\n  error.code = code;\n  if (loc) {\n    error.location = loc;\n  }\n  error.domain = domain;\n  return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n  throw error;\n}\nvar RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nvar detectHtmlTag = function detectHtmlTag(source) {\n  return RE_HTML_TAG.test(source);\n};\nvar CHAR_SP = ' ';\nvar CHAR_CR = '\\r';\nvar CHAR_LF = '\\n';\nvar CHAR_LS = String.fromCharCode(0x2028);\nvar CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n  var _buf = str;\n  var _index = 0;\n  var _line = 1;\n  var _column = 1;\n  var _peekOffset = 0;\n  var isCRLF = function isCRLF(index) {\n    return _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n  };\n  var isLF = function isLF(index) {\n    return _buf[index] === CHAR_LF;\n  };\n  var isPS = function isPS(index) {\n    return _buf[index] === CHAR_PS;\n  };\n  var isLS = function isLS(index) {\n    return _buf[index] === CHAR_LS;\n  };\n  var isLineEnd = function isLineEnd(index) {\n    return isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n  };\n  var index = function index() {\n    return _index;\n  };\n  var line = function line() {\n    return _line;\n  };\n  var column = function column() {\n    return _column;\n  };\n  var peekOffset = function peekOffset() {\n    return _peekOffset;\n  };\n  var charAt = function charAt(offset) {\n    return isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n  };\n  var currentChar = function currentChar() {\n    return charAt(_index);\n  };\n  var currentPeek = function currentPeek() {\n    return charAt(_index + _peekOffset);\n  };\n  function next() {\n    _peekOffset = 0;\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n    if (isCRLF(_index)) {\n      _index++;\n    }\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n  function resetPeek() {\n    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    _peekOffset = offset;\n  }\n  function skipToPeek() {\n    var target = _index + _peekOffset;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (target !== _index) {\n      next();\n    }\n    _peekOffset = 0;\n  }\n  return {\n    index: index,\n    line: line,\n    column: column,\n    peekOffset: peekOffset,\n    charAt: charAt,\n    currentChar: currentChar,\n    currentPeek: currentPeek,\n    next: next,\n    peek: peek,\n    reset: reset,\n    resetPeek: resetPeek,\n    skipToPeek: skipToPeek\n  };\n}\nvar EOF = undefined;\nvar DOT = '.';\nvar LITERAL_DELIMITER = \"'\";\nvar ERROR_DOMAIN$3 = 'tokenizer';\nfunction createTokenizer(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var location = options.location !== false;\n  var _scnr = createScanner(source);\n  var currentOffset = function currentOffset() {\n    return _scnr.index();\n  };\n  var currentPosition = function currentPosition() {\n    return createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n  };\n  var _initLoc = currentPosition();\n  var _initOffset = currentOffset();\n  var _context = {\n    currentType: 14 /* TokenTypes.EOF */,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 14 /* TokenTypes.EOF */,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n  var context = function context() {\n    return _context;\n  };\n  var onError = options.onError;\n  function emitError(code, pos, offset) {\n    var ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n    if (onError) {\n      var loc = location ? createLocation(ctx.startLoc, pos) : null;\n      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        args[_key2 - 3] = arguments[_key2];\n      }\n      var err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$3,\n        args: args\n      });\n      onError(err);\n    }\n  }\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    var token = {\n      type: type\n    };\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n    if (value != null) {\n      token.value = value;\n    }\n    return token;\n  }\n  var getEndToken = function getEndToken(context) {\n    return getToken(context, 14 /* TokenTypes.EOF */);\n  };\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n      return '';\n    }\n  }\n  function peekSpaces(scnr) {\n    var buf = '';\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n    return buf;\n  }\n  function skipSpaces(scnr) {\n    var buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    var cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 ||\n    // a-z\n    cc >= 65 && cc <= 90 ||\n    // A-Z\n    cc === 95 // _\n    ;\n  }\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    var cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n  function isNamedIdentifierStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isListIdentifierStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    var ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLiteralStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDotStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 8 /* TokenTypes.LinkedAlias */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedModifierStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 9 /* TokenTypes.LinkedDot */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDelimiterStart(scnr, context) {\n    var currentType = context.currentType;\n    if (!(currentType === 8 /* TokenTypes.LinkedAlias */ || currentType === 12 /* TokenTypes.LinkedModifier */)) {\n      return false;\n    }\n    peekSpaces(scnr);\n    var ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedReferStart(scnr, context) {\n    var currentType = context.currentType;\n    if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {\n      return false;\n    }\n    var fn = function fn() {\n      var ch = scnr.currentPeek();\n      if (ch === \"{\" /* TokenChars.BraceLeft */) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"%\" /* TokenChars.Modulo */ || ch === \"|\" /* TokenChars.Pipe */ || ch === \":\" /* TokenChars.LinkedDelimiter */ || ch === \".\" /* TokenChars.LinkedDot */ || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isIdentifierStart(ch);\n      }\n    };\n    var ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    var ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function detectModuloStart(scnr) {\n    var spaces = peekSpaces(scnr);\n    var ret = scnr.currentPeek() === \"%\" /* TokenChars.Modulo */ && scnr.peek() === \"{\" /* TokenChars.BraceLeft */;\n    scnr.resetPeek();\n    return {\n      isModulo: ret,\n      hasSpace: spaces.length > 0\n    };\n  }\n  function isTextStart(scnr) {\n    var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var fn = function fn() {\n      var hasSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var detectModulo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ch = scnr.currentPeek();\n      if (ch === \"{\" /* TokenChars.BraceLeft */) {\n        return prev === \"%\" /* TokenChars.Modulo */ ? false : hasSpace;\n      } else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n        return prev === \"%\" /* TokenChars.Modulo */ ? true : hasSpace;\n      } else if (ch === \"%\" /* TokenChars.Modulo */) {\n        scnr.peek();\n        return fn(hasSpace, \"%\" /* TokenChars.Modulo */, true);\n      } else if (ch === \"|\" /* TokenChars.Pipe */) {\n        return prev === \"%\" /* TokenChars.Modulo */ || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP, detectModulo);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF, detectModulo);\n      } else {\n        return true;\n      }\n    };\n    var ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n  function takeChar(scnr, fn) {\n    var ch = scnr.currentChar();\n    if (ch === EOF) {\n      return EOF;\n    }\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n    return null;\n  }\n  function takeIdentifierChar(scnr) {\n    var closure = function closure(ch) {\n      var cc = ch.charCodeAt(0);\n      return cc >= 97 && cc <= 122 ||\n      // a-z\n      cc >= 65 && cc <= 90 ||\n      // A-Z\n      cc >= 48 && cc <= 57 ||\n      // 0-9\n      cc === 95 ||\n      // _\n      cc === 36 // $\n      ;\n    };\n    return takeChar(scnr, closure);\n  }\n  function takeDigit(scnr) {\n    var closure = function closure(ch) {\n      var cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57; // 0-9\n    };\n    return takeChar(scnr, closure);\n  }\n  function takeHexDigit(scnr) {\n    var closure = function closure(ch) {\n      var cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57 ||\n      // 0-9\n      cc >= 65 && cc <= 70 ||\n      // A-F\n      cc >= 97 && cc <= 102; // a-f\n    };\n    return takeChar(scnr, closure);\n  }\n  function getDigits(scnr) {\n    var ch = '';\n    var num = '';\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n    return num;\n  }\n  function readModulo(scnr) {\n    skipSpaces(scnr);\n    var ch = scnr.currentChar();\n    if (ch !== \"%\" /* TokenChars.Modulo */) {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n    }\n    scnr.next();\n    return \"%\" /* TokenChars.Modulo */;\n  }\n  function readText(scnr) {\n    var buf = '';\n    while (true) {\n      var ch = scnr.currentChar();\n      if (ch === \"{\" /* TokenChars.BraceLeft */ || ch === \"}\" /* TokenChars.BraceRight */ || ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"|\" /* TokenChars.Pipe */ || !ch) {\n        break;\n      } else if (ch === \"%\" /* TokenChars.Modulo */) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else {\n          break;\n        }\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n    return buf;\n  }\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    var ch = '';\n    var name = '';\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return name;\n  }\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    var value = '';\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += \"-\".concat(getDigits(scnr));\n    } else {\n      value += getDigits(scnr);\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return value;\n  }\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    eat(scnr, \"'\");\n    var ch = '';\n    var literal = '';\n    var fn = function fn(x) {\n      return x !== LITERAL_DELIMITER && x !== CHAR_LF;\n    };\n    while (ch = takeChar(scnr, fn)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n    var current = scnr.currentChar();\n    if (current === CHAR_LF || current === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n      // TODO: Is it correct really?\n      if (current === CHAR_LF) {\n        scnr.next();\n        eat(scnr, \"'\");\n      }\n      return literal;\n    }\n    eat(scnr, \"'\");\n    return literal;\n  }\n  function readEscapeSequence(scnr) {\n    var ch = scnr.currentChar();\n    switch (ch) {\n      case '\\\\':\n      case \"'\":\n        scnr.next();\n        return \"\\\\\".concat(ch);\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n      default:\n        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n        return '';\n    }\n  }\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    var sequence = '';\n    for (var i = 0; i < digits; i++) {\n      var ch = takeHexDigit(scnr);\n      if (!ch) {\n        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, \"\\\\\".concat(unicode).concat(sequence).concat(scnr.currentChar()));\n        break;\n      }\n      sequence += ch;\n    }\n    return \"\\\\\".concat(unicode).concat(sequence);\n  }\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    var ch = '';\n    var identifiers = '';\n    var closure = function closure(ch) {\n      return ch !== \"{\" /* TokenChars.BraceLeft */ && ch !== \"}\" /* TokenChars.BraceRight */ && ch !== CHAR_SP && ch !== CHAR_LF;\n    };\n    while (ch = takeChar(scnr, closure)) {\n      identifiers += ch;\n    }\n    return identifiers;\n  }\n  function readLinkedModifier(scnr) {\n    var ch = '';\n    var name = '';\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n    return name;\n  }\n  function readLinkedRefer(scnr) {\n    var fn = function fn() {\n      var detect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var buf = arguments.length > 1 ? arguments[1] : undefined;\n      var ch = scnr.currentChar();\n      if (ch === \"{\" /* TokenChars.BraceLeft */ || ch === \"%\" /* TokenChars.Modulo */ || ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"|\" /* TokenChars.Pipe */ || ch === \"(\" /* TokenChars.ParenLeft */ || ch === \")\" /* TokenChars.ParenRight */ || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF || ch === DOT) {\n        buf += ch;\n        scnr.next();\n        return fn(detect, buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(true, buf);\n      }\n    };\n    return fn(false, '');\n  }\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    var plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n    skipSpaces(scnr);\n    return plural;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInPlaceholder(scnr, context) {\n    var token = null;\n    var ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* TokenChars.BraceLeft */:\n        if (context.braceNest >= 1) {\n          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n      case \"}\" /* TokenChars.BraceRight */:\n        if (context.braceNest > 0 && context.currentType === 2 /* TokenTypes.BraceLeft */) {\n          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n        return token;\n      case \"@\" /* TokenChars.LinkedAlias */:\n        if (context.braceNest > 0) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n      default:\n        var validNamedIdentifier = true;\n        var validListIdentifier = true;\n        var validLiteral = true;\n        if (isPluralStart(scnr)) {\n          if (context.braceNest > 0) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          }\n          token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        if (context.braceNest > 0 && (context.currentType === 5 /* TokenTypes.Named */ || context.currentType === 6 /* TokenTypes.List */ || context.currentType === 7 /* TokenTypes.Literal */)) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          context.braceNest = 0;\n          return readToken(scnr, context);\n        }\n        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n          token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n          token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (validLiteral = isLiteralStart(scnr, context)) {\n          token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n          token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n          skipSpaces(scnr);\n          return token;\n        }\n        break;\n    }\n    return token;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInLinked(scnr, context) {\n    var currentType = context.currentType;\n    var token = null;\n    var ch = scnr.currentChar();\n    if ((currentType === 8 /* TokenTypes.LinkedAlias */ || currentType === 9 /* TokenTypes.LinkedDot */ || currentType === 12 /* TokenTypes.LinkedModifier */ || currentType === 10 /* TokenTypes.LinkedDelimiter */) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n    }\n    switch (ch) {\n      case \"@\" /* TokenChars.LinkedAlias */:\n        scnr.next();\n        token = getToken(context, 8 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n        context.inLinked = true;\n        return token;\n      case \".\" /* TokenChars.LinkedDot */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n      case \":\" /* TokenChars.LinkedDelimiter */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n        }\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n          if (ch === \"{\" /* TokenChars.BraceLeft */) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n          }\n        }\n        if (currentType === 8 /* TokenTypes.LinkedAlias */) {\n          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readToken(scnr, context) {\n    var token = {\n      type: 14 /* TokenTypes.EOF */\n    };\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n    var ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* TokenChars.BraceLeft */:\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n      case \"}\" /* TokenChars.BraceRight */:\n        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n      case \"@\" /* TokenChars.LinkedAlias */:\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        var _detectModuloStart = detectModuloStart(scnr),\n          isModulo = _detectModuloStart.isModulo,\n          hasSpace = _detectModuloStart.hasSpace;\n        if (isModulo) {\n          return hasSpace ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr)) : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));\n        }\n        if (isTextStart(scnr)) {\n          return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n        }\n        break;\n    }\n    return token;\n  }\n  function nextToken() {\n    var currentType = _context.currentType,\n      offset = _context.offset,\n      startLoc = _context.startLoc,\n      endLoc = _context.endLoc;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 14 /* TokenTypes.EOF */);\n    }\n    return readToken(_scnr, _context);\n  }\n  return {\n    nextToken: nextToken,\n    currentOffset: currentOffset,\n    currentPosition: currentPosition,\n    context: context\n  };\n}\nvar ERROR_DOMAIN$2 = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nvar KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case \"\\\\\\\\\":\n      return \"\\\\\";\n    case \"\\\\'\":\n      return \"'\";\n    default:\n      {\n        var codePoint = parseInt(codePoint4 || codePoint6, 16);\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        }\n        // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n        return '�';\n      }\n  }\n}\nfunction createParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var location = options.location !== false;\n  var onError = options.onError;\n  function emitError(tokenzer, code, start, offset) {\n    var end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n    if (onError) {\n      var loc = location ? createLocation(start, end) : null;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 4 ? _len3 - 4 : 0), _key3 = 4; _key3 < _len3; _key3++) {\n        args[_key3 - 4] = arguments[_key3];\n      }\n      var err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$2,\n        args: args\n      });\n      onError(err);\n    }\n  }\n  function startNode(type, offset, loc) {\n    var node = {\n      type: type\n    };\n    if (location) {\n      node.start = offset;\n      node.end = offset;\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n    return node;\n  }\n  function endNode(node, offset, pos, type) {\n    if (type) {\n      node.type = type;\n    }\n    if (location) {\n      node.end = offset;\n      if (node.loc) {\n        node.loc.end = pos;\n      }\n    }\n  }\n  function parseText(tokenizer, value) {\n    var context = tokenizer.context();\n    var node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseList(tokenizer, index) {\n    var context = tokenizer.context();\n    var offset = context.lastOffset,\n      loc = context.lastStartLoc; // get brace left loc\n    var node = startNode(5 /* NodeTypes.List */, offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseNamed(tokenizer, key) {\n    var context = tokenizer.context();\n    var offset = context.lastOffset,\n      loc = context.lastStartLoc; // get brace left loc\n    var node = startNode(4 /* NodeTypes.Named */, offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLiteral(tokenizer, value) {\n    var context = tokenizer.context();\n    var offset = context.lastOffset,\n      loc = context.lastStartLoc; // get brace left loc\n    var node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinkedModifier(tokenizer) {\n    var token = tokenizer.nextToken();\n    var context = tokenizer.context();\n    var offset = context.lastOffset,\n      loc = context.lastStartLoc; // get linked dot loc\n    var node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n    if (token.type !== 12 /* TokenTypes.LinkedModifier */) {\n      // empty modifier\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node: node\n      };\n    }\n    // check token\n    if (token.value == null) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: node\n    };\n  }\n  function parseLinkedKey(tokenizer, value) {\n    var context = tokenizer.context();\n    var node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinked(tokenizer) {\n    var context = tokenizer.context();\n    var linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n    var token = tokenizer.nextToken();\n    if (token.type === 9 /* TokenTypes.LinkedDot */) {\n      var parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    }\n    // asset check token\n    if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    token = tokenizer.nextToken();\n    // skip brace left\n    if (token.type === 2 /* TokenTypes.BraceLeft */) {\n      token = tokenizer.nextToken();\n    }\n    switch (token.type) {\n      case 11 /* TokenTypes.LinkedKey */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n      case 5 /* TokenTypes.Named */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n      case 6 /* TokenTypes.List */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n      case 7 /* TokenTypes.Literal */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n      default:\n        // empty key\n        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n        var nextContext = tokenizer.context();\n        var emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n        emptyLinkedKeyNode.value = '';\n        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n        linkedNode.key = emptyLinkedKeyNode;\n        endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n        return {\n          nextConsumeToken: token,\n          node: linkedNode\n        };\n    }\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n  function parseMessage(tokenizer) {\n    var context = tokenizer.context();\n    var startOffset = context.currentType === 1 /* TokenTypes.Pipe */ ? tokenizer.currentOffset() : context.offset;\n    var startLoc = context.currentType === 1 /* TokenTypes.Pipe */ ? context.endLoc : context.startLoc;\n    var node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n    node.items = [];\n    var nextToken = null;\n    do {\n      var token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n      switch (token.type) {\n        case 0 /* TokenTypes.Text */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n        case 6 /* TokenTypes.List */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n        case 5 /* TokenTypes.Named */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n        case 7 /* TokenTypes.Literal */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n        case 8 /* TokenTypes.LinkedAlias */:\n          var parsed = parseLinked(tokenizer);\n          node.items.push(parsed.node);\n          nextToken = parsed.nextConsumeToken || null;\n          break;\n      }\n    } while (context.currentType !== 14 /* TokenTypes.EOF */ && context.currentType !== 1 /* TokenTypes.Pipe */);\n    // adjust message node loc\n    var endOffset = context.currentType === 1 /* TokenTypes.Pipe */ ? context.lastOffset : tokenizer.currentOffset();\n    var endLoc = context.currentType === 1 /* TokenTypes.Pipe */ ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    var context = tokenizer.context();\n    var hasEmptyMessage = msgNode.items.length === 0;\n    var node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n    do {\n      var msg = parseMessage(tokenizer);\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n      node.cases.push(msg);\n    } while (context.currentType !== 14 /* TokenTypes.EOF */);\n    if (hasEmptyMessage) {\n      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseResource(tokenizer) {\n    var context = tokenizer.context();\n    var offset = context.offset,\n      startLoc = context.startLoc;\n    var msgNode = parseMessage(tokenizer);\n    if (context.currentType === 14 /* TokenTypes.EOF */) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n  function parse(source) {\n    var tokenizer = createTokenizer(source, assign({}, options));\n    var context = tokenizer.context();\n    var node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n    node.body = parseResource(tokenizer);\n    if (options.onCacheKey) {\n      node.cacheKey = options.onCacheKey(source);\n    }\n    // assert whether achieved to EOF\n    if (context.currentType !== 14 /* TokenTypes.EOF */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  return {\n    parse: parse\n  };\n}\nfunction getTokenCaption(token) {\n  if (token.type === 14 /* TokenTypes.EOF */) {\n    return 'EOF';\n  }\n  var name = (token.value || '').replace(/\\r?\\n/g, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\nfunction createTransformer(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _context = {\n    ast: ast,\n    helpers: new Set()\n  };\n  var context = function context() {\n    return _context;\n  };\n  var helper = function helper(name) {\n    _context.helpers.add(name);\n    return name;\n  };\n  return {\n    context: context,\n    helper: helper\n  };\n}\nfunction traverseNodes(nodes, transformer) {\n  for (var i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1 /* NodeTypes.Plural */:\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n      break;\n    case 2 /* NodeTypes.Message */:\n      traverseNodes(node.items, transformer);\n      break;\n    case 6 /* NodeTypes.Linked */:\n      var linked = node;\n      traverseNode(linked.key, transformer);\n      transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n      transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n      break;\n    case 5 /* NodeTypes.List */:\n      transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n      transformer.helper(\"list\" /* HelperNameMap.LIST */);\n      break;\n    case 4 /* NodeTypes.Named */:\n      transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n      transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n      break;\n  }\n  // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var transformer = createTransformer(ast);\n  transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n  // traverse\n  ast.body && traverseNode(ast.body, transformer);\n  // set meta information\n  var context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\nfunction optimize(ast) {\n  var body = ast.body;\n  if (body.type === 2 /* NodeTypes.Message */) {\n    optimizeMessageNode(body);\n  } else {\n    body.cases.forEach(function (c) {\n      return optimizeMessageNode(c);\n    });\n  }\n  return ast;\n}\nfunction optimizeMessageNode(message) {\n  if (message.items.length === 1) {\n    var item = message.items[0];\n    if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n      message.static = item.value;\n      delete item.value; // optimization for size\n    }\n  } else {\n    var values = [];\n    for (var i = 0; i < message.items.length; i++) {\n      var _item = message.items[i];\n      if (!(_item.type === 3 /* NodeTypes.Text */ || _item.type === 9 /* NodeTypes.Literal */)) {\n        break;\n      }\n      if (_item.value == null) {\n        break;\n      }\n      values.push(_item.value);\n    }\n    if (values.length === message.items.length) {\n      message.static = join(values);\n      for (var _i = 0; _i < message.items.length; _i++) {\n        var _item2 = message.items[_i];\n        if (_item2.type === 3 /* NodeTypes.Text */ || _item2.type === 9 /* NodeTypes.Literal */) {\n          delete _item2.value; // optimization for size\n        }\n      }\n    }\n  }\n}\nvar ERROR_DOMAIN$1 = 'minifier';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction minify(node) {\n  node.t = node.type;\n  switch (node.type) {\n    case 0 /* NodeTypes.Resource */:\n      var resource = node;\n      minify(resource.body);\n      resource.b = resource.body;\n      delete resource.body;\n      break;\n    case 1 /* NodeTypes.Plural */:\n      var plural = node;\n      var cases = plural.cases;\n      for (var i = 0; i < cases.length; i++) {\n        minify(cases[i]);\n      }\n      plural.c = cases;\n      delete plural.cases;\n      break;\n    case 2 /* NodeTypes.Message */:\n      var message = node;\n      var items = message.items;\n      for (var _i2 = 0; _i2 < items.length; _i2++) {\n        minify(items[_i2]);\n      }\n      message.i = items;\n      delete message.items;\n      if (message.static) {\n        message.s = message.static;\n        delete message.static;\n      }\n      break;\n    case 3 /* NodeTypes.Text */:\n    case 9 /* NodeTypes.Literal */:\n    case 8 /* NodeTypes.LinkedModifier */:\n    case 7 /* NodeTypes.LinkedKey */:\n      var valueNode = node;\n      if (valueNode.value) {\n        valueNode.v = valueNode.value;\n        delete valueNode.value;\n      }\n      break;\n    case 6 /* NodeTypes.Linked */:\n      var linked = node;\n      minify(linked.key);\n      linked.k = linked.key;\n      delete linked.key;\n      if (linked.modifier) {\n        minify(linked.modifier);\n        linked.m = linked.modifier;\n        delete linked.modifier;\n      }\n      break;\n    case 5 /* NodeTypes.List */:\n      var list = node;\n      list.i = list.index;\n      delete list.index;\n      break;\n    case 4 /* NodeTypes.Named */:\n      var named = node;\n      named.k = named.key;\n      delete named.key;\n      break;\n    default:\n      {\n        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {\n          domain: ERROR_DOMAIN$1,\n          args: [node.type]\n        });\n      }\n  }\n  delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nvar ERROR_DOMAIN = 'parser';\nfunction createCodeGenerator(ast, options) {\n  var sourceMap = options.sourceMap,\n    filename = options.filename,\n    breakLineCode = options.breakLineCode,\n    _needIndent = options.needIndent;\n  var location = options.location !== false;\n  var _context = {\n    filename: filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode: breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n  if (location && ast.loc) {\n    _context.source = ast.loc.source;\n  }\n  var context = function context() {\n    return _context;\n  };\n  function push(code, node) {\n    _context.code += code;\n  }\n  function _newline(n) {\n    var withBreakLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var _breakLineCode = withBreakLine ? breakLineCode : '';\n    push(_needIndent ? _breakLineCode + \"  \".repeat(n) : _breakLineCode);\n  }\n  function indent() {\n    var withNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function deindent() {\n    var withNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n  var helper = function helper(key) {\n    return \"_\".concat(key);\n  };\n  var needIndent = function needIndent() {\n    return _context.needIndent;\n  };\n  return {\n    context: context,\n    push: push,\n    indent: indent,\n    deindent: deindent,\n    newline: newline,\n    helper: helper,\n    needIndent: needIndent\n  };\n}\nfunction generateLinkedNode(generator, node) {\n  var helper = generator.helper;\n  generator.push(\"\".concat(helper(\"linked\" /* HelperNameMap.LINKED */), \"(\"));\n  generateNode(generator, node.key);\n  if (node.modifier) {\n    generator.push(\", \");\n    generateNode(generator, node.modifier);\n    generator.push(\", _type\");\n  } else {\n    generator.push(\", undefined, _type\");\n  }\n  generator.push(\")\");\n}\nfunction generateMessageNode(generator, node) {\n  var helper = generator.helper,\n    needIndent = generator.needIndent;\n  generator.push(\"\".concat(helper(\"normalize\" /* HelperNameMap.NORMALIZE */), \"([\"));\n  generator.indent(needIndent());\n  var length = node.items.length;\n  for (var i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n    if (i === length - 1) {\n      break;\n    }\n    generator.push(', ');\n  }\n  generator.deindent(needIndent());\n  generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n  var helper = generator.helper,\n    needIndent = generator.needIndent;\n  if (node.cases.length > 1) {\n    generator.push(\"\".concat(helper(\"plural\" /* HelperNameMap.PLURAL */), \"([\"));\n    generator.indent(needIndent());\n    var length = node.cases.length;\n    for (var i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n      if (i === length - 1) {\n        break;\n      }\n      generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push(\"])\");\n  }\n}\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\nfunction generateNode(generator, node) {\n  var helper = generator.helper;\n  switch (node.type) {\n    case 0 /* NodeTypes.Resource */:\n      generateResource(generator, node);\n      break;\n    case 1 /* NodeTypes.Plural */:\n      generatePluralNode(generator, node);\n      break;\n    case 2 /* NodeTypes.Message */:\n      generateMessageNode(generator, node);\n      break;\n    case 6 /* NodeTypes.Linked */:\n      generateLinkedNode(generator, node);\n      break;\n    case 8 /* NodeTypes.LinkedModifier */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 7 /* NodeTypes.LinkedKey */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 5 /* NodeTypes.List */:\n      generator.push(\"\".concat(helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */), \"(\").concat(helper(\"list\" /* HelperNameMap.LIST */), \"(\").concat(node.index, \"))\"), node);\n      break;\n    case 4 /* NodeTypes.Named */:\n      generator.push(\"\".concat(helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */), \"(\").concat(helper(\"named\" /* HelperNameMap.NAMED */), \"(\").concat(JSON.stringify(node.key), \"))\"), node);\n      break;\n    case 9 /* NodeTypes.Literal */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 3 /* NodeTypes.Text */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    default:\n      {\n        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {\n          domain: ERROR_DOMAIN,\n          args: [node.type]\n        });\n      }\n  }\n}\n// generate code from AST\nvar generate = function generate(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mode = isString(options.mode) ? options.mode : 'normal';\n  var filename = isString(options.filename) ? options.filename : 'message.intl';\n  var sourceMap = !!options.sourceMap;\n  // prettier-ignore\n  var breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  var needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  var helpers = ast.helpers || [];\n  var generator = createCodeGenerator(ast, {\n    mode: mode,\n    filename: filename,\n    sourceMap: sourceMap,\n    breakLineCode: breakLineCode,\n    needIndent: needIndent\n  });\n  generator.push(mode === 'normal' ? \"function __msg__ (ctx) {\" : \"(ctx) => {\");\n  generator.indent(needIndent);\n  if (helpers.length > 0) {\n    generator.push(\"const { \".concat(join(helpers.map(function (s) {\n      return \"\".concat(s, \": _\").concat(s);\n    }), ', '), \" } = ctx\"));\n    generator.newline();\n  }\n  generator.push(\"return \");\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(\"}\");\n  delete ast.helpers;\n  var _generator$context = generator.context(),\n    code = _generator$context.code,\n    map = _generator$context.map;\n  return {\n    ast: ast,\n    code: code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n  };\n};\nfunction baseCompile(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var assignedOptions = assign({}, options);\n  var jit = !!assignedOptions.jit;\n  var enalbeMinify = !!assignedOptions.minify;\n  var enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n  // parse source codes\n  var parser = createParser(assignedOptions);\n  var ast = parser.parse(source);\n  if (!jit) {\n    // transform ASTs\n    transform(ast, assignedOptions);\n    // generate javascript codes\n    return generate(ast, assignedOptions);\n  } else {\n    // optimize ASTs\n    enambeOptimize && optimize(ast);\n    // minimize ASTs\n    enalbeMinify && minify(ast);\n    // In JIT mode, no ast transform, no code generation.\n    return {\n      ast: ast,\n      code: ''\n    };\n  }\n}\nexport { CompileErrorCodes, ERROR_DOMAIN$2 as ERROR_DOMAIN, LOCATION_STUB, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, detectHtmlTag, errorMessages };","map":{"version":3,"names":["LOCATION_STUB","start","line","column","offset","end","createPosition","createLocation","source","loc","RE_ARGS","format","message","_len","arguments","length","args","Array","_key","isObject","hasOwnProperty","replace","match","identifier","assign","Object","isString","val","_typeof","join","items","separator","undefined","reduce","str","item","index","CompileErrorCodes","EXPECTED_TOKEN","INVALID_TOKEN_IN_PLACEHOLDER","UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER","UNKNOWN_ESCAPE_SEQUENCE","INVALID_UNICODE_ESCAPE_SEQUENCE","UNBALANCED_CLOSING_BRACE","UNTERMINATED_CLOSING_BRACE","EMPTY_PLACEHOLDER","NOT_ALLOW_NEST_PLACEHOLDER","INVALID_LINKED_FORMAT","MUST_HAVE_MESSAGES_IN_PLURAL","UNEXPECTED_EMPTY_LINKED_MODIFIER","UNEXPECTED_EMPTY_LINKED_KEY","UNEXPECTED_LEXICAL_ANALYSIS","UNHANDLED_CODEGEN_NODE_TYPE","UNHANDLED_MINIFIER_NODE_TYPE","__EXTEND_POINT__","errorMessages","_errorMessages","_defineProperty","createCompileError","code","options","domain","messages","msg","apply","concat","_toConsumableArray","error","SyntaxError","String","location","defaultOnError","RE_HTML_TAG","detectHtmlTag","test","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","fromCharCode","CHAR_PS","createScanner","_buf","_index","_line","_column","_peekOffset","isCRLF","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","DOT","LITERAL_DELIMITER","ERROR_DOMAIN$3","createTokenizer","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","_context","currentType","startLoc","endLoc","lastType","lastOffset","lastStartLoc","lastEndLoc","braceNest","inLinked","text","context","onError","emitError","pos","ctx","_len2","_key2","err","getToken","type","value","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","charCodeAt","isNumberStart","isNamedIdentifierStart","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isPluralStart","detectModuloStart","spaces","isModulo","hasSpace","isTextStart","prev","detectModulo","takeChar","takeIdentifierChar","closure","takeDigit","takeHexDigit","getDigits","num","readModulo","readText","readNamedIdentifier","name","readListIdentifier","readLiteral","literal","x","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","i","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","detect","readPlural","plural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","_detectModuloStart","nextToken","ERROR_DOMAIN$2","KNOWN_ESCAPES","fromEscapeSequence","codePoint4","codePoint6","codePoint","parseInt","fromCodePoint","createParser","tokenzer","_len3","_key3","startNode","node","endNode","parseText","tokenizer","parseList","parseNamed","key","parseLiteral","parseLinkedModifier","nextConsumeToken","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","modifier","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","push","endOffset","parsePlural","msgNode","hasEmptyMessage","cases","parseResource","parse","body","onCacheKey","cacheKey","slice","createTransformer","ast","helpers","Set","helper","add","traverseNodes","nodes","transformer","traverseNode","linked","transform","from","optimize","optimizeMessageNode","forEach","c","static","values","ERROR_DOMAIN$1","minify","t","resource","b","s","valueNode","v","k","m","list","named","ERROR_DOMAIN","createCodeGenerator","sourceMap","filename","breakLineCode","_needIndent","needIndent","map","indentLevel","_newline","n","withBreakLine","_breakLineCode","repeat","indent","withNewLine","level","deindent","newline","generateLinkedNode","generator","generateNode","generateMessageNode","generatePluralNode","generateResource","JSON","stringify","generate","mode","_generator$context","toJSON","baseCompile","assignedOptions","jit","enalbeMinify","enambeOptimize","parser"],"sources":["C:/Users/brnol/Documents/Hospital/Hospital_equipo/node_modules/@intlify/message-compiler/dist/message-compiler.esm-browser.js"],"sourcesContent":["/*!\n  * message-compiler v9.10.1\n  * (c) 2024 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nconst LOCATION_STUB = {\n    start: { line: 1, column: 1, offset: 0 },\n    end: { line: 1, column: 1, offset: 0 }\n};\nfunction createPosition(line, column, offset) {\n    return { line, column, offset };\n}\nfunction createLocation(start, end, source) {\n    const loc = { start, end };\n    if (source != null) {\n        loc.source = source;\n    }\n    return loc;\n}\n\n/**\n * Original Utilities\n * written by kazuya kawaguchi\n */\nconst RE_ARGS = /\\{([0-9a-zA-Z]+)\\}/g;\n/* eslint-disable */\nfunction format(message, ...args) {\n    if (args.length === 1 && isObject(args[0])) {\n        args = args[0];\n    }\n    if (!args || !args.hasOwnProperty) {\n        args = {};\n    }\n    return message.replace(RE_ARGS, (match, identifier) => {\n        return args.hasOwnProperty(identifier) ? args[identifier] : '';\n    });\n}\nconst assign = Object.assign;\nconst isString = (val) => typeof val === 'string';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isObject = (val) => val !== null && typeof val === 'object';\nfunction join(items, separator = '') {\n    return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');\n}\n\nconst CompileErrorCodes = {\n    // tokenizer error codes\n    EXPECTED_TOKEN: 1,\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n    UNBALANCED_CLOSING_BRACE: 6,\n    UNTERMINATED_CLOSING_BRACE: 7,\n    EMPTY_PLACEHOLDER: 8,\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\n    INVALID_LINKED_FORMAT: 10,\n    // parser error codes\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\n    // generator error codes\n    UNHANDLED_CODEGEN_NODE_TYPE: 15,\n    // minifier error codes\n    UNHANDLED_MINIFIER_NODE_TYPE: 16,\n    // Special value for higher-order compilers to pick up the last code\n    // to avoid collision of error codes. This should always be kept as the last\n    // item.\n    __EXTEND_POINT__: 17\n};\n/** @internal */\nconst errorMessages = {\n    // tokenizer error messages\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n    // parser error messages\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,\n    // generator error messages\n    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,\n    // minimizer error messages\n    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n    const { domain, messages, args } = options;\n    const msg = format((messages || errorMessages)[code] || '', ...(args || []))\n        ;\n    const error = new SyntaxError(String(msg));\n    error.code = code;\n    if (loc) {\n        error.location = loc;\n    }\n    error.domain = domain;\n    return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n    throw error;\n}\n\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst detectHtmlTag = (source) => RE_HTML_TAG.test(source);\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n    const _buf = str;\n    let _index = 0;\n    let _line = 1;\n    let _column = 1;\n    let _peekOffset = 0;\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n    const isLF = (index) => _buf[index] === CHAR_LF;\n    const isPS = (index) => _buf[index] === CHAR_PS;\n    const isLS = (index) => _buf[index] === CHAR_LS;\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n    const index = () => _index;\n    const line = () => _line;\n    const column = () => _column;\n    const peekOffset = () => _peekOffset;\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n    const currentChar = () => charAt(_index);\n    const currentPeek = () => charAt(_index + _peekOffset);\n    function next() {\n        _peekOffset = 0;\n        if (isLineEnd(_index)) {\n            _line++;\n            _column = 0;\n        }\n        if (isCRLF(_index)) {\n            _index++;\n        }\n        _index++;\n        _column++;\n        return _buf[_index];\n    }\n    function peek() {\n        if (isCRLF(_index + _peekOffset)) {\n            _peekOffset++;\n        }\n        _peekOffset++;\n        return _buf[_index + _peekOffset];\n    }\n    function reset() {\n        _index = 0;\n        _line = 1;\n        _column = 1;\n        _peekOffset = 0;\n    }\n    function resetPeek(offset = 0) {\n        _peekOffset = offset;\n    }\n    function skipToPeek() {\n        const target = _index + _peekOffset;\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while (target !== _index) {\n            next();\n        }\n        _peekOffset = 0;\n    }\n    return {\n        index,\n        line,\n        column,\n        peekOffset,\n        charAt,\n        currentChar,\n        currentPeek,\n        next,\n        peek,\n        reset,\n        resetPeek,\n        skipToPeek\n    };\n}\n\nconst EOF = undefined;\nconst DOT = '.';\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$3 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n    const location = options.location !== false;\n    const _scnr = createScanner(source);\n    const currentOffset = () => _scnr.index();\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n    const _initLoc = currentPosition();\n    const _initOffset = currentOffset();\n    const _context = {\n        currentType: 14 /* TokenTypes.EOF */,\n        offset: _initOffset,\n        startLoc: _initLoc,\n        endLoc: _initLoc,\n        lastType: 14 /* TokenTypes.EOF */,\n        lastOffset: _initOffset,\n        lastStartLoc: _initLoc,\n        lastEndLoc: _initLoc,\n        braceNest: 0,\n        inLinked: false,\n        text: ''\n    };\n    const context = () => _context;\n    const { onError } = options;\n    function emitError(code, pos, offset, ...args) {\n        const ctx = context();\n        pos.column += offset;\n        pos.offset += offset;\n        if (onError) {\n            const loc = location ? createLocation(ctx.startLoc, pos) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$3,\n                args\n            });\n            onError(err);\n        }\n    }\n    function getToken(context, type, value) {\n        context.endLoc = currentPosition();\n        context.currentType = type;\n        const token = { type };\n        if (location) {\n            token.loc = createLocation(context.startLoc, context.endLoc);\n        }\n        if (value != null) {\n            token.value = value;\n        }\n        return token;\n    }\n    const getEndToken = (context) => getToken(context, 14 /* TokenTypes.EOF */);\n    function eat(scnr, ch) {\n        if (scnr.currentChar() === ch) {\n            scnr.next();\n            return ch;\n        }\n        else {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n            return '';\n        }\n    }\n    function peekSpaces(scnr) {\n        let buf = '';\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n            buf += scnr.currentPeek();\n            scnr.peek();\n        }\n        return buf;\n    }\n    function skipSpaces(scnr) {\n        const buf = peekSpaces(scnr);\n        scnr.skipToPeek();\n        return buf;\n    }\n    function isIdentifierStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            cc === 95 // _\n        );\n    }\n    function isNumberStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function isNamedIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isListIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n        const ret = isNumberStart(ch);\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLiteralStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDotStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 8 /* TokenTypes.LinkedAlias */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedModifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 9 /* TokenTypes.LinkedDot */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDelimiterStart(scnr, context) {\n        const { currentType } = context;\n        if (!(currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */)) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedReferStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {\n            return false;\n        }\n        const fn = () => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return isIdentifierStart(scnr.peek());\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \":\" /* TokenChars.LinkedDelimiter */ ||\n                ch === \".\" /* TokenChars.LinkedDot */ ||\n                ch === CHAR_SP ||\n                !ch) {\n                return false;\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn();\n            }\n            else {\n                // other characters\n                return isIdentifierStart(ch);\n            }\n        };\n        const ret = fn();\n        scnr.resetPeek();\n        return ret;\n    }\n    function isPluralStart(scnr) {\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function detectModuloStart(scnr) {\n        const spaces = peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"%\" /* TokenChars.Modulo */ &&\n            scnr.peek() === \"{\" /* TokenChars.BraceLeft */;\n        scnr.resetPeek();\n        return {\n            isModulo: ret,\n            hasSpace: spaces.length > 0\n        };\n    }\n    function isTextStart(scnr, reset = true) {\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? false : hasSpace;\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? true : hasSpace;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                scnr.peek();\n                return fn(hasSpace, \"%\" /* TokenChars.Modulo */, true);\n            }\n            else if (ch === \"|\" /* TokenChars.Pipe */) {\n                return prev === \"%\" /* TokenChars.Modulo */ || detectModulo\n                    ? true\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\n            }\n            else if (ch === CHAR_SP) {\n                scnr.peek();\n                return fn(true, CHAR_SP, detectModulo);\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn(true, CHAR_LF, detectModulo);\n            }\n            else {\n                return true;\n            }\n        };\n        const ret = fn();\n        reset && scnr.resetPeek();\n        return ret;\n    }\n    function takeChar(scnr, fn) {\n        const ch = scnr.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (fn(ch)) {\n            scnr.next();\n            return ch;\n        }\n        return null;\n    }\n    function takeIdentifierChar(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 97 && cc <= 122) || // a-z\n                (cc >= 65 && cc <= 90) || // A-Z\n                (cc >= 48 && cc <= 57) || // 0-9\n                cc === 95 || // _\n                cc === 36 // $\n            );\n        };\n        return takeChar(scnr, closure);\n    }\n    function takeDigit(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return cc >= 48 && cc <= 57; // 0-9\n        };\n        return takeChar(scnr, closure);\n    }\n    function takeHexDigit(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 48 && cc <= 57) || // 0-9\n                (cc >= 65 && cc <= 70) || // A-F\n                (cc >= 97 && cc <= 102)); // a-f\n        };\n        return takeChar(scnr, closure);\n    }\n    function getDigits(scnr) {\n        let ch = '';\n        let num = '';\n        while ((ch = takeDigit(scnr))) {\n            num += ch;\n        }\n        return num;\n    }\n    function readModulo(scnr) {\n        skipSpaces(scnr);\n        const ch = scnr.currentChar();\n        if (ch !== \"%\" /* TokenChars.Modulo */) {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n        }\n        scnr.next();\n        return \"%\" /* TokenChars.Modulo */;\n    }\n    function readText(scnr) {\n        let buf = '';\n        while (true) {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"}\" /* TokenChars.BraceRight */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                !ch) {\n                break;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else if (isPluralStart(scnr)) {\n                    break;\n                }\n                else {\n                    buf += ch;\n                    scnr.next();\n                }\n            }\n            else {\n                buf += ch;\n                scnr.next();\n            }\n        }\n        return buf;\n    }\n    function readNamedIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return name;\n    }\n    function readListIdentifier(scnr) {\n        skipSpaces(scnr);\n        let value = '';\n        if (scnr.currentChar() === '-') {\n            scnr.next();\n            value += `-${getDigits(scnr)}`;\n        }\n        else {\n            value += getDigits(scnr);\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return value;\n    }\n    function readLiteral(scnr) {\n        skipSpaces(scnr);\n        eat(scnr, `\\'`);\n        let ch = '';\n        let literal = '';\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n        while ((ch = takeChar(scnr, fn))) {\n            if (ch === '\\\\') {\n                literal += readEscapeSequence(scnr);\n            }\n            else {\n                literal += ch;\n            }\n        }\n        const current = scnr.currentChar();\n        if (current === CHAR_LF || current === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n            // TODO: Is it correct really?\n            if (current === CHAR_LF) {\n                scnr.next();\n                eat(scnr, `\\'`);\n            }\n            return literal;\n        }\n        eat(scnr, `\\'`);\n        return literal;\n    }\n    function readEscapeSequence(scnr) {\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case '\\\\':\n            case `\\'`:\n                scnr.next();\n                return `\\\\${ch}`;\n            case 'u':\n                return readUnicodeEscapeSequence(scnr, ch, 4);\n            case 'U':\n                return readUnicodeEscapeSequence(scnr, ch, 6);\n            default:\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n                return '';\n        }\n    }\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\n        eat(scnr, unicode);\n        let sequence = '';\n        for (let i = 0; i < digits; i++) {\n            const ch = takeHexDigit(scnr);\n            if (!ch) {\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n                break;\n            }\n            sequence += ch;\n        }\n        return `\\\\${unicode}${sequence}`;\n    }\n    function readInvalidIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let identifiers = '';\n        const closure = (ch) => ch !== \"{\" /* TokenChars.BraceLeft */ &&\n            ch !== \"}\" /* TokenChars.BraceRight */ &&\n            ch !== CHAR_SP &&\n            ch !== CHAR_LF;\n        while ((ch = takeChar(scnr, closure))) {\n            identifiers += ch;\n        }\n        return identifiers;\n    }\n    function readLinkedModifier(scnr) {\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        return name;\n    }\n    function readLinkedRefer(scnr) {\n        const fn = (detect = false, buf) => {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \"(\" /* TokenChars.ParenLeft */ ||\n                ch === \")\" /* TokenChars.ParenRight */ ||\n                !ch) {\n                return buf;\n            }\n            else if (ch === CHAR_SP) {\n                return buf;\n            }\n            else if (ch === CHAR_LF || ch === DOT) {\n                buf += ch;\n                scnr.next();\n                return fn(detect, buf);\n            }\n            else {\n                buf += ch;\n                scnr.next();\n                return fn(true, buf);\n            }\n        };\n        return fn(false, '');\n    }\n    function readPlural(scnr) {\n        skipSpaces(scnr);\n        const plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n        skipSpaces(scnr);\n        return plural;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInPlaceholder(scnr, context) {\n        let token = null;\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                if (context.braceNest >= 1) {\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n                skipSpaces(scnr);\n                context.braceNest++;\n                return token;\n            case \"}\" /* TokenChars.BraceRight */:\n                if (context.braceNest > 0 &&\n                    context.currentType === 2 /* TokenTypes.BraceLeft */) {\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n                context.braceNest--;\n                context.braceNest > 0 && skipSpaces(scnr);\n                if (context.inLinked && context.braceNest === 0) {\n                    context.inLinked = false;\n                }\n                return token;\n            case \"@\" /* TokenChars.LinkedAlias */:\n                if (context.braceNest > 0) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                }\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\n                context.braceNest = 0;\n                return token;\n            default:\n                let validNamedIdentifier = true;\n                let validListIdentifier = true;\n                let validLiteral = true;\n                if (isPluralStart(scnr)) {\n                    if (context.braceNest > 0) {\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    }\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (context.braceNest > 0 &&\n                    (context.currentType === 5 /* TokenTypes.Named */ ||\n                        context.currentType === 6 /* TokenTypes.List */ ||\n                        context.currentType === 7 /* TokenTypes.Literal */)) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    context.braceNest = 0;\n                    return readToken(scnr, context);\n                }\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\n                    token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\n                    token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validLiteral = isLiteralStart(scnr, context))) {\n                    token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n                    token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n                    skipSpaces(scnr);\n                    return token;\n                }\n                break;\n        }\n        return token;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInLinked(scnr, context) {\n        const { currentType } = context;\n        let token = null;\n        const ch = scnr.currentChar();\n        if ((currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 9 /* TokenTypes.LinkedDot */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */ ||\n            currentType === 10 /* TokenTypes.LinkedDelimiter */) &&\n            (ch === CHAR_LF || ch === CHAR_SP)) {\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        switch (ch) {\n            case \"@\" /* TokenChars.LinkedAlias */:\n                scnr.next();\n                token = getToken(context, 8 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n                context.inLinked = true;\n                return token;\n            case \".\" /* TokenChars.LinkedDot */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 9 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n            case \":\" /* TokenChars.LinkedDelimiter */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (isLinkedDotStart(scnr, context) ||\n                    isLinkedDelimiterStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return readTokenInLinked(scnr, context);\n                }\n                if (isLinkedModifierStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n                }\n                if (isLinkedReferStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                        // scan the placeholder\n                        return readTokenInPlaceholder(scnr, context) || token;\n                    }\n                    else {\n                        return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n                    }\n                }\n                if (currentType === 8 /* TokenTypes.LinkedAlias */) {\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n                }\n                context.braceNest = 0;\n                context.inLinked = false;\n                return readToken(scnr, context);\n        }\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readToken(scnr, context) {\n        let token = { type: 14 /* TokenTypes.EOF */ };\n        if (context.braceNest > 0) {\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n        }\n        if (context.inLinked) {\n            return readTokenInLinked(scnr, context) || getEndToken(context);\n        }\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n            case \"}\" /* TokenChars.BraceRight */:\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n                scnr.next();\n                return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n            case \"@\" /* TokenChars.LinkedAlias */:\n                return readTokenInLinked(scnr, context) || getEndToken(context);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                const { isModulo, hasSpace } = detectModuloStart(scnr);\n                if (isModulo) {\n                    return hasSpace\n                        ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr))\n                        : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));\n                }\n                if (isTextStart(scnr)) {\n                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n                }\n                break;\n        }\n        return token;\n    }\n    function nextToken() {\n        const { currentType, offset, startLoc, endLoc } = _context;\n        _context.lastType = currentType;\n        _context.lastOffset = offset;\n        _context.lastStartLoc = startLoc;\n        _context.lastEndLoc = endLoc;\n        _context.offset = currentOffset();\n        _context.startLoc = currentPosition();\n        if (_scnr.currentChar() === EOF) {\n            return getToken(_context, 14 /* TokenTypes.EOF */);\n        }\n        return readToken(_scnr, _context);\n    }\n    return {\n        nextToken,\n        currentOffset,\n        currentPosition,\n        context\n    };\n}\n\nconst ERROR_DOMAIN$2 = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n    switch (match) {\n        case `\\\\\\\\`:\n            return `\\\\`;\n        case `\\\\\\'`:\n            return `\\'`;\n        default: {\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n                return String.fromCodePoint(codePoint);\n            }\n            // invalid ...\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\n            return '�';\n        }\n    }\n}\nfunction createParser(options = {}) {\n    const location = options.location !== false;\n    const { onError } = options;\n    function emitError(tokenzer, code, start, offset, ...args) {\n        const end = tokenzer.currentPosition();\n        end.offset += offset;\n        end.column += offset;\n        if (onError) {\n            const loc = location ? createLocation(start, end) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$2,\n                args\n            });\n            onError(err);\n        }\n    }\n    function startNode(type, offset, loc) {\n        const node = { type };\n        if (location) {\n            node.start = offset;\n            node.end = offset;\n            node.loc = { start: loc, end: loc };\n        }\n        return node;\n    }\n    function endNode(node, offset, pos, type) {\n        if (type) {\n            node.type = type;\n        }\n        if (location) {\n            node.end = offset;\n            if (node.loc) {\n                node.loc.end = pos;\n            }\n        }\n    }\n    function parseText(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseList(tokenizer, index) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(5 /* NodeTypes.List */, offset, loc);\n        node.index = parseInt(index, 10);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseNamed(tokenizer, key) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(4 /* NodeTypes.Named */, offset, loc);\n        node.key = key;\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLiteral(tokenizer, value) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinkedModifier(tokenizer) {\n        const token = tokenizer.nextToken();\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\n        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n        if (token.type !== 12 /* TokenTypes.LinkedModifier */) {\n            // empty modifier\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n            node.value = '';\n            endNode(node, offset, loc);\n            return {\n                nextConsumeToken: token,\n                node\n            };\n        }\n        // check token\n        if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        node.value = token.value || '';\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node\n        };\n    }\n    function parseLinkedKey(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinked(tokenizer) {\n        const context = tokenizer.context();\n        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n        let token = tokenizer.nextToken();\n        if (token.type === 9 /* TokenTypes.LinkedDot */) {\n            const parsed = parseLinkedModifier(tokenizer);\n            linkedNode.modifier = parsed.node;\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\n        }\n        // asset check token\n        if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        token = tokenizer.nextToken();\n        // skip brace left\n        if (token.type === 2 /* TokenTypes.BraceLeft */) {\n            token = tokenizer.nextToken();\n        }\n        switch (token.type) {\n            case 11 /* TokenTypes.LinkedKey */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n                break;\n            case 5 /* TokenTypes.Named */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\n                break;\n            case 6 /* TokenTypes.List */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseList(tokenizer, token.value || '');\n                break;\n            case 7 /* TokenTypes.Literal */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\n                break;\n            default:\n                // empty key\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n                const nextContext = tokenizer.context();\n                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n                emptyLinkedKeyNode.value = '';\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n                linkedNode.key = emptyLinkedKeyNode;\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n                return {\n                    nextConsumeToken: token,\n                    node: linkedNode\n                };\n        }\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node: linkedNode\n        };\n    }\n    function parseMessage(tokenizer) {\n        const context = tokenizer.context();\n        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? tokenizer.currentOffset()\n            : context.offset;\n        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.endLoc\n            : context.startLoc;\n        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n        node.items = [];\n        let nextToken = null;\n        do {\n            const token = nextToken || tokenizer.nextToken();\n            nextToken = null;\n            switch (token.type) {\n                case 0 /* TokenTypes.Text */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseText(tokenizer, token.value || ''));\n                    break;\n                case 6 /* TokenTypes.List */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseList(tokenizer, token.value || ''));\n                    break;\n                case 5 /* TokenTypes.Named */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\n                    break;\n                case 7 /* TokenTypes.Literal */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\n                    break;\n                case 8 /* TokenTypes.LinkedAlias */:\n                    const parsed = parseLinked(tokenizer);\n                    node.items.push(parsed.node);\n                    nextToken = parsed.nextConsumeToken || null;\n                    break;\n            }\n        } while (context.currentType !== 14 /* TokenTypes.EOF */ &&\n            context.currentType !== 1 /* TokenTypes.Pipe */);\n        // adjust message node loc\n        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastOffset\n            : tokenizer.currentOffset();\n        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastEndLoc\n            : tokenizer.currentPosition();\n        endNode(node, endOffset, endLoc);\n        return node;\n    }\n    function parsePlural(tokenizer, offset, loc, msgNode) {\n        const context = tokenizer.context();\n        let hasEmptyMessage = msgNode.items.length === 0;\n        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n        node.cases = [];\n        node.cases.push(msgNode);\n        do {\n            const msg = parseMessage(tokenizer);\n            if (!hasEmptyMessage) {\n                hasEmptyMessage = msg.items.length === 0;\n            }\n            node.cases.push(msg);\n        } while (context.currentType !== 14 /* TokenTypes.EOF */);\n        if (hasEmptyMessage) {\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseResource(tokenizer) {\n        const context = tokenizer.context();\n        const { offset, startLoc } = context;\n        const msgNode = parseMessage(tokenizer);\n        if (context.currentType === 14 /* TokenTypes.EOF */) {\n            return msgNode;\n        }\n        else {\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\n        }\n    }\n    function parse(source) {\n        const tokenizer = createTokenizer(source, assign({}, options));\n        const context = tokenizer.context();\n        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n        if (location && node.loc) {\n            node.loc.source = source;\n        }\n        node.body = parseResource(tokenizer);\n        if (options.onCacheKey) {\n            node.cacheKey = options.onCacheKey(source);\n        }\n        // assert whether achieved to EOF\n        if (context.currentType !== 14 /* TokenTypes.EOF */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    return { parse };\n}\nfunction getTokenCaption(token) {\n    if (token.type === 14 /* TokenTypes.EOF */) {\n        return 'EOF';\n    }\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n    const _context = {\n        ast,\n        helpers: new Set()\n    };\n    const context = () => _context;\n    const helper = (name) => {\n        _context.helpers.add(name);\n        return name;\n    };\n    return { context, helper };\n}\nfunction traverseNodes(nodes, transformer) {\n    for (let i = 0; i < nodes.length; i++) {\n        traverseNode(nodes[i], transformer);\n    }\n}\nfunction traverseNode(node, transformer) {\n    // TODO: if we need pre-hook of transform, should be implemented to here\n    switch (node.type) {\n        case 1 /* NodeTypes.Plural */:\n            traverseNodes(node.cases, transformer);\n            transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n            break;\n        case 2 /* NodeTypes.Message */:\n            traverseNodes(node.items, transformer);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            const linked = node;\n            traverseNode(linked.key, transformer);\n            transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n            transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n            break;\n        case 5 /* NodeTypes.List */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"list\" /* HelperNameMap.LIST */);\n            break;\n        case 4 /* NodeTypes.Named */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n            break;\n    }\n    // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n    const transformer = createTransformer(ast);\n    transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n    // traverse\n    ast.body && traverseNode(ast.body, transformer);\n    // set meta information\n    const context = transformer.context();\n    ast.helpers = Array.from(context.helpers);\n}\n\nfunction optimize(ast) {\n    const body = ast.body;\n    if (body.type === 2 /* NodeTypes.Message */) {\n        optimizeMessageNode(body);\n    }\n    else {\n        body.cases.forEach(c => optimizeMessageNode(c));\n    }\n    return ast;\n}\nfunction optimizeMessageNode(message) {\n    if (message.items.length === 1) {\n        const item = message.items[0];\n        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n            message.static = item.value;\n            delete item.value; // optimization for size\n        }\n    }\n    else {\n        const values = [];\n        for (let i = 0; i < message.items.length; i++) {\n            const item = message.items[i];\n            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {\n                break;\n            }\n            if (item.value == null) {\n                break;\n            }\n            values.push(item.value);\n        }\n        if (values.length === message.items.length) {\n            message.static = join(values);\n            for (let i = 0; i < message.items.length; i++) {\n                const item = message.items[i];\n                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n                    delete item.value; // optimization for size\n                }\n            }\n        }\n    }\n}\n\nconst ERROR_DOMAIN$1 = 'minifier';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction minify(node) {\n    node.t = node.type;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            const resource = node;\n            minify(resource.body);\n            resource.b = resource.body;\n            delete resource.body;\n            break;\n        case 1 /* NodeTypes.Plural */:\n            const plural = node;\n            const cases = plural.cases;\n            for (let i = 0; i < cases.length; i++) {\n                minify(cases[i]);\n            }\n            plural.c = cases;\n            delete plural.cases;\n            break;\n        case 2 /* NodeTypes.Message */:\n            const message = node;\n            const items = message.items;\n            for (let i = 0; i < items.length; i++) {\n                minify(items[i]);\n            }\n            message.i = items;\n            delete message.items;\n            if (message.static) {\n                message.s = message.static;\n                delete message.static;\n            }\n            break;\n        case 3 /* NodeTypes.Text */:\n        case 9 /* NodeTypes.Literal */:\n        case 8 /* NodeTypes.LinkedModifier */:\n        case 7 /* NodeTypes.LinkedKey */:\n            const valueNode = node;\n            if (valueNode.value) {\n                valueNode.v = valueNode.value;\n                delete valueNode.value;\n            }\n            break;\n        case 6 /* NodeTypes.Linked */:\n            const linked = node;\n            minify(linked.key);\n            linked.k = linked.key;\n            delete linked.key;\n            if (linked.modifier) {\n                minify(linked.modifier);\n                linked.m = linked.modifier;\n                delete linked.modifier;\n            }\n            break;\n        case 5 /* NodeTypes.List */:\n            const list = node;\n            list.i = list.index;\n            delete list.index;\n            break;\n        case 4 /* NodeTypes.Named */:\n            const named = node;\n            named.k = named.key;\n            delete named.key;\n            break;\n        default:\n            {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN$1,\n                    args: [node.type]\n                });\n            }\n    }\n    delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nconst ERROR_DOMAIN = 'parser';\nfunction createCodeGenerator(ast, options) {\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\n    const location = options.location !== false;\n    const _context = {\n        filename,\n        code: '',\n        column: 1,\n        line: 1,\n        offset: 0,\n        map: undefined,\n        breakLineCode,\n        needIndent: _needIndent,\n        indentLevel: 0\n    };\n    if (location && ast.loc) {\n        _context.source = ast.loc.source;\n    }\n    const context = () => _context;\n    function push(code, node) {\n        _context.code += code;\n    }\n    function _newline(n, withBreakLine = true) {\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n    }\n    function indent(withNewLine = true) {\n        const level = ++_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function deindent(withNewLine = true) {\n        const level = --_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function newline() {\n        _newline(_context.indentLevel);\n    }\n    const helper = (key) => `_${key}`;\n    const needIndent = () => _context.needIndent;\n    return {\n        context,\n        push,\n        indent,\n        deindent,\n        newline,\n        helper,\n        needIndent\n    };\n}\nfunction generateLinkedNode(generator, node) {\n    const { helper } = generator;\n    generator.push(`${helper(\"linked\" /* HelperNameMap.LINKED */)}(`);\n    generateNode(generator, node.key);\n    if (node.modifier) {\n        generator.push(`, `);\n        generateNode(generator, node.modifier);\n        generator.push(`, _type`);\n    }\n    else {\n        generator.push(`, undefined, _type`);\n    }\n    generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n    const { helper, needIndent } = generator;\n    generator.push(`${helper(\"normalize\" /* HelperNameMap.NORMALIZE */)}([`);\n    generator.indent(needIndent());\n    const length = node.items.length;\n    for (let i = 0; i < length; i++) {\n        generateNode(generator, node.items[i]);\n        if (i === length - 1) {\n            break;\n        }\n        generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n    const { helper, needIndent } = generator;\n    if (node.cases.length > 1) {\n        generator.push(`${helper(\"plural\" /* HelperNameMap.PLURAL */)}([`);\n        generator.indent(needIndent());\n        const length = node.cases.length;\n        for (let i = 0; i < length; i++) {\n            generateNode(generator, node.cases[i]);\n            if (i === length - 1) {\n                break;\n            }\n            generator.push(', ');\n        }\n        generator.deindent(needIndent());\n        generator.push(`])`);\n    }\n}\nfunction generateResource(generator, node) {\n    if (node.body) {\n        generateNode(generator, node.body);\n    }\n    else {\n        generator.push('null');\n    }\n}\nfunction generateNode(generator, node) {\n    const { helper } = generator;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            generateResource(generator, node);\n            break;\n        case 1 /* NodeTypes.Plural */:\n            generatePluralNode(generator, node);\n            break;\n        case 2 /* NodeTypes.Message */:\n            generateMessageNode(generator, node);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            generateLinkedNode(generator, node);\n            break;\n        case 8 /* NodeTypes.LinkedModifier */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 7 /* NodeTypes.LinkedKey */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 5 /* NodeTypes.List */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"list\" /* HelperNameMap.LIST */)}(${node.index}))`, node);\n            break;\n        case 4 /* NodeTypes.Named */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"named\" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);\n            break;\n        case 9 /* NodeTypes.Literal */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 3 /* NodeTypes.Text */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        default:\n            {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN,\n                    args: [node.type]\n                });\n            }\n    }\n}\n// generate code from AST\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n    const mode = isString(options.mode) ? options.mode : 'normal';\n    const filename = isString(options.filename)\n        ? options.filename\n        : 'message.intl';\n    const sourceMap = !!options.sourceMap;\n    // prettier-ignore\n    const breakLineCode = options.breakLineCode != null\n        ? options.breakLineCode\n        : mode === 'arrow'\n            ? ';'\n            : '\\n';\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n    const helpers = ast.helpers || [];\n    const generator = createCodeGenerator(ast, {\n        mode,\n        filename,\n        sourceMap,\n        breakLineCode,\n        needIndent\n    });\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n    generator.indent(needIndent);\n    if (helpers.length > 0) {\n        generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);\n        generator.newline();\n    }\n    generator.push(`return `);\n    generateNode(generator, ast);\n    generator.deindent(needIndent);\n    generator.push(`}`);\n    delete ast.helpers;\n    const { code, map } = generator.context();\n    return {\n        ast,\n        code,\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n    };\n};\n\nfunction baseCompile(source, options = {}) {\n    const assignedOptions = assign({}, options);\n    const jit = !!assignedOptions.jit;\n    const enalbeMinify = !!assignedOptions.minify;\n    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n    // parse source codes\n    const parser = createParser(assignedOptions);\n    const ast = parser.parse(source);\n    if (!jit) {\n        // transform ASTs\n        transform(ast, assignedOptions);\n        // generate javascript codes\n        return generate(ast, assignedOptions);\n    }\n    else {\n        // optimize ASTs\n        enambeOptimize && optimize(ast);\n        // minimize ASTs\n        enalbeMinify && minify(ast);\n        // In JIT mode, no ast transform, no code generation.\n        return { ast, code: '' };\n    }\n}\n\nexport { CompileErrorCodes, ERROR_DOMAIN$2 as ERROR_DOMAIN, LOCATION_STUB, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, detectHtmlTag, errorMessages };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}