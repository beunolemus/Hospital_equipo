{"ast":null,"code":"import \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * DateAxis module\r\n */\nimport { __assign, __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar DateAxisDataItem = /** @class */function (_super) {\n  __extends(DateAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"DateAxisDataItem\";\n    _this.applyTheme();\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function get() {\n      return this.dates[\"date\"];\n    },\n    /**\r\n     * Date position of the data item.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function set(date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\r\n     * @return End date\r\n     */\n    get: function get() {\n      return this.dates[\"endDate\"];\n    },\n    /**\r\n     * End date for data item.\r\n     *\r\n     * @param date End date\r\n     */\n    set: function set(date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\nexport { DateAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\nvar DateAxis = /** @class */function (_super) {\n  __extends(DateAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxis() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this._gapBreaks = false;\n    /**\r\n     * A list of date/time intervals for Date axis.\r\n     *\r\n     * This define various granularities available for the axis. For example\r\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n     * the axis will choose the granularity of 10 minutes, displaying a label\r\n     * every 10 minutes.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *  { timeUnit: \"millisecond\", count: 1 },\r\n     *  { timeUnit: \"millisecond\", count: 5 },\r\n     *  { timeUnit: \"millisecond\", count: 10 },\r\n     *  { timeUnit: \"millisecond\", count: 50 },\r\n     *  { timeUnit: \"millisecond\", count: 100 },\r\n     *  { timeUnit: \"millisecond\", count: 500 },\r\n     *  { timeUnit: \"second\", count: 1 },\r\n     *  { timeUnit: \"second\", count: 5 },\r\n     *  { timeUnit: \"second\", count: 10 },\r\n     *  { timeUnit: \"second\", count: 30 },\r\n     *  { timeUnit: \"minute\", count: 1 },\r\n     *  { timeUnit: \"minute\", count: 5 },\r\n     *  { timeUnit: \"minute\", count: 10 },\r\n     *  { timeUnit: \"minute\", count: 30 },\r\n     *  { timeUnit: \"hour\", count: 1 },\r\n     *  { timeUnit: \"hour\", count: 3 },\r\n     *  { timeUnit: \"hour\", count: 6 },\r\n     *  { timeUnit: \"hour\", count: 12 },\r\n     *  { timeUnit: \"day\", count: 1 },\r\n     *  { timeUnit: \"day\", count: 2 },\r\n     *  { timeUnit: \"day\", count: 3 },\r\n     *  { timeUnit: \"day\", count: 4 },\r\n     *  { timeUnit: \"day\", count: 5 },\r\n     *  { timeUnit: \"week\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 2 },\r\n     *  { timeUnit: \"month\", count: 3 },\r\n     *  { timeUnit: \"month\", count: 6 },\r\n     *  { timeUnit: \"year\", count: 1 },\r\n     *  { timeUnit: \"year\", count: 2 },\r\n     *  { timeUnit: \"year\", count: 5 },\r\n     *  { timeUnit: \"year\", count: 10 },\r\n     *  { timeUnit: \"year\", count: 50 },\r\n     *  { timeUnit: \"year\", count: 100 }\r\n     * ]\r\n     * ```\r\n     */\n    _this.gridIntervals = new List();\n    /**\r\n     * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n     * chart will try to aggregate data items into grouped data items.\r\n     *\r\n     * If there are more data items in selected period than `groupCount`, it will\r\n     * group data items into bigger period.\r\n     *\r\n     * For example seconds might be grouped into 10-second aggregate data items.\r\n     *\r\n     * This setting indicates what group intervals can the chart group to.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { timeUnit: \"millisecond\", count: 1},\r\n     *   { timeUnit: \"millisecond\", count: 10 },\r\n     *   { timeUnit: \"millisecond\", count: 100 },\r\n     *   { timeUnit: \"second\", count: 1 },\r\n     *   { timeUnit: \"second\", count: 10 },\r\n     *   { timeUnit: \"minute\", count: 1 },\r\n     *   { timeUnit: \"minute\", count: 10 },\r\n     *   { timeUnit: \"hour\", count: 1 },\r\n     *   { timeUnit: \"day\", count: 1 },\r\n     *   { timeUnit: \"week\", count: 1 },\r\n     *   { timeUnit: \"month\", count: 1 },\r\n     *   { timeUnit: \"year\", count: 1 }\r\n     * ]\r\n     * ```\r\n     * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n     *\r\n     * @since 4.7.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     */\n    _this.groupIntervals = new List();\n    /**\r\n     * A collection of date formats to use when formatting different time units\r\n     * on Date/time axis.\r\n     *\r\n     * Actual defaults will depend on the language locale set for the chart.\r\n     *\r\n     * To override format for a specific time unit, say days, you need to set\r\n     * the appropriate key to a format string. E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JSON\r\n     * \"xAxes\": [{\r\n     *   \"type\": \"DateAxis\",\r\n     *   \"dateFormats\": {\r\n     *     \"day\": \"MMMM d, yyyy\"\r\n     *   }\r\n     * }]\r\n     * ```\r\n     *\r\n     * @see {@link DateFormatter}\r\n     */\n    _this.dateFormats = new Dictionary();\n    /**\r\n     * These formats are applied to labels that are first in a larger unit.\r\n     *\r\n     * For example, if we have a DateAxis with days on it, the first day of month\r\n     * indicates a break in month - a start of the bigger period.\r\n     *\r\n     * For those labels, `periodChangeDateFormats` are applied instead of\r\n     * `dateFormats`.\r\n     *\r\n     * This allows us implement convenient structures, like instead of:\r\n     *\r\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n     *\r\n     * We can have:\r\n     *\r\n     * `Jan - 1 - 2 - 3 - ...`\r\n     *\r\n     * This can be disabled by setting `markUnitChange = false`.\r\n     */\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\r\n     * Actual interval (granularity) derived from the actual data.\r\n     */\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\r\n     */\n    _this._prevSeriesTime = {};\n    /**\r\n     * [_minDifference description]\r\n     *\r\n     * @todo Description\r\n     */\n    _this._minDifference = {};\n    /**\r\n     * @ignore\r\n     */\n    _this._firstWeekDay = 1;\n    /**\r\n     * A collection of start timestamps to use as axis' min timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMin = {};\n    /**\r\n     * A collection of start timestamps to use as axis' max timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMax = {};\n    _this._intervalMax = {};\n    _this._intervalMin = {};\n    _this.className = \"DateAxis\";\n    _this.setPropertyValue(\"markUnitChange\", true);\n    _this.snapTooltip = true;\n    _this.tooltipPosition = \"pointer\";\n    _this.setPropertyValue(\"groupData\", false);\n    _this.groupCount = 200;\n    _this.events.on(\"parentset\", _this.getDFFormatter, _this, false);\n    // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]);\n    _this.groupIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }]);\n    // Set field name\n    _this.axisFieldName = \"date\";\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * A function which applies fills to axis cells.\r\n   *\r\n   * Default function fills every second fill. You can set this to a function\r\n   * that follows some other logic.\r\n   *\r\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n   * property accordingly.\r\n   */\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n    // Set default date formats\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\r\n   * Validates Axis' data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var baseDuration = this.baseDuration;\n    var periodCount = (this.max - this.min) / baseDuration;\n    this._firstWeekDay = this.getFirstWeekDay();\n    this.getDFFormatter();\n    _super.prototype.validateDataItems.call(this);\n    var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\n    this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\n    this._deltaMinMax = this.baseDuration / 2;\n    // allows to keep selection of the same size\n    var newPeriodCount = (this.max - this.min) / baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\r\n   * Handles process after zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Does nothing?\r\n   */\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getIntervalMax = function (interval) {\n    return this._intervalMax[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getIntervalMin = function (interval) {\n    return this._intervalMin[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n    _super.prototype.calculateZoom.call(this);\n    var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\n    var dataSetChanged = false;\n    // if data has to be grouped, choose interval and set dataset\n    if (this.groupData && $type.hasValue(difference)) {\n      var mainBaseInterval = this.mainBaseInterval;\n      var min = this.getIntervalMin(mainBaseInterval);\n      var max = this.getIntervalMax(mainBaseInterval);\n      var selectionMin = min + (max - min) * this.start;\n      var selectionMax = min + (max - min) * this.end;\n      var diff = this.adjustDifference(selectionMin, selectionMax);\n      var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\n      var groupInterval = void 0;\n      if (this.groupInterval) {\n        groupInterval = __assign({}, this.groupInterval);\n      } else {\n        groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\n        if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\n          groupInterval = __assign({}, mainBaseInterval);\n        }\n      }\n      this._groupInterval = groupInterval;\n      var newId = groupInterval.timeUnit + groupInterval.count;\n      if (this._currentDataSetId != newId) {\n        this._currentDataSetId = newId;\n        this.dispatch(\"groupperiodchanged\");\n      }\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          if (series.setDataSet(_this._currentDataSetId)) {\n            dataSetChanged = true;\n          }\n        }\n      });\n    }\n    var gridInterval = this.chooseInterval(0, difference, this._gridCount);\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = __assign({}, this.baseInterval);\n    }\n    this._gridInterval = gridInterval;\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n    // the following is needed to avoid grid flickering while scrolling\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    // tell series start/end\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\n        var startIndex = 0;\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        }\n        // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\n        var endIndex = series.dataItems.length;\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\");\n            // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\n            //if (endIndex < series.dataItems.length) {\n            endIndex++;\n            //}\n          }\n        }\n        if (series.max(_this) < minZoomed) {\n          series.startIndex = series.dataItems.length;\n          series.endIndex = series.dataItems.length;\n          series.outOfRange = true;\n        } else if (series.min(_this) > maxZoomed) {\n          series.startIndex = 0;\n          series.endIndex = 0;\n          series.outOfRange = true;\n        } else {\n          series.outOfRange = false;\n          series.startIndex = startIndex;\n          series.endIndex = endIndex;\n        }\n        //\tconsole.log(series.name, startIndex, endIndex);\n        if (!dataSetChanged && series.dataRangeInvalid) {\n          series.validateDataRange();\n        }\n      }\n    });\n  };\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * (Re)validates data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function get() {\n      var _this = this;\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\r\n   * [postProcessSeriesDataItems description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItems = function (series) {\n    var _this = this;\n    this._firstWeekDay = this.getFirstWeekDay();\n    if (series) {\n      this.seriesGroupUpdate(series);\n    } else {\n      this.series.each(function (series) {\n        _this.seriesGroupUpdate(series);\n      });\n    }\n    this.addEmptyUnitsBreaks();\n  };\n  DateAxis.prototype.seriesGroupUpdate = function (series) {\n    var _this = this;\n    if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\n      series._baseInterval[this.uid] = this.mainBaseInterval;\n      series.mainDataSet.each(function (dataItem) {\n        _this.postProcessSeriesDataItem(dataItem);\n      });\n      if (this.groupData) {\n        this.groupSeriesData(series);\n      }\n    }\n  };\n  /**\r\n   * Calculates series group data.\r\n   *\r\n   * @param  series  Series\r\n   * @ignore\r\n   */\n  DateAxis.prototype.groupSeriesData = function (series) {\n    var _this = this;\n    if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\n      series.bulletsContainer.removeChildren();\n      // make array of intervals which will be used;\n      var intervals_1 = [];\n      var mainBaseInterval = this.mainBaseInterval;\n      var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\n      this.groupIntervals.each(function (interval) {\n        var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\n        if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {\n          intervals_1.push(interval);\n        }\n      });\n      if (series._dataSets) {\n        series._dataSets.each(function (key, dataItems) {\n          dataItems.each(function (dataItem) {\n            dataItem.dispose();\n          });\n          dataItems.clear();\n        });\n        series._dataSets.clear();\n      }\n      series.dataGrouped = true;\n      $array.each(intervals_1, function (interval) {\n        //let mainBaseInterval = this._mainBaseInterval;\n        var key = \"date\" + _this.axisLetter;\n        // create data set\n        var dataSetId = interval.timeUnit + interval.count;\n        // todo: check where this clone goes\n        var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\n        series.dataSets.setKey(dataSetId, dataSet);\n        var dataItems = series.mainDataSet;\n        var previousTime = Number.NEGATIVE_INFINITY;\n        var i = 0;\n        var newDataItem;\n        var dataFields = [];\n        $object.each(series.dataFields, function (dfkey, df) {\n          var dfk = dfkey;\n          if (dfk != key && dfk.indexOf(\"Show\") == -1) {\n            dataFields.push(dfk);\n          }\n        });\n        var roundedDate;\n        dataItems.each(function (dataItem) {\n          var date = dataItem.getDate(key);\n          if (date) {\n            var time = date.getTime();\n            roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n            var currentTime = roundedDate.getTime();\n            // changed period\t\t\t\t\t\t\t\t\n            if (previousTime < currentTime) {\n              if (newDataItem && series._adapterO) {\n                $array.each(dataFields, function (vkey) {\n                  newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n                    dataItem: newDataItem,\n                    interval: interval,\n                    dataField: vkey,\n                    date: roundedDate,\n                    value: newDataItem.values[vkey].value\n                  }).value;\n                  newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n                });\n              }\n              newDataItem = dataSet.create();\n              newDataItem.dataContext = {};\n              newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\n              newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\n              newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\n              newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\n              newDataItem.component = series;\n              // other Dates?\n              newDataItem.setDate(key, roundedDate);\n              newDataItem._index = i;\n              i++;\n              $array.each(dataFields, function (vkey) {\n                //let groupFieldName = vkey + \"Group\";\n                var dvalues = dataItem.values[vkey];\n                if (dvalues) {\n                  var value = dvalues.value;\n                  if (series._adapterO) {\n                    value = series._adapterO.apply(\"groupValue\", {\n                      dataItem: dataItem,\n                      interval: interval,\n                      dataField: vkey,\n                      date: roundedDate,\n                      value: value\n                    }).value;\n                  }\n                  var values = newDataItem.values[vkey];\n                  if ($type.isNumber(value)) {\n                    values.value = value;\n                    values.workingValue = value;\n                    values.open = value;\n                    values.close = value;\n                    values.low = value;\n                    values.high = value;\n                    values.sum = value;\n                    values.average = value;\n                    values.count = 1;\n                  } else {\n                    values.count = 0;\n                  }\n                }\n              });\n              _this.postProcessSeriesDataItem(newDataItem, interval);\n              $object.each(series.propertyFields, function (key, fieldValue) {\n                var f = key;\n                var value = dataItem.properties[key];\n                if ($type.hasValue(value)) {\n                  newDataItem.hasProperties = true;\n                  newDataItem.setProperty(f, value);\n                }\n              });\n              newDataItem.groupDataItems = [dataItem];\n              previousTime = currentTime;\n            } else {\n              if (newDataItem) {\n                $array.each(dataFields, function (vkey) {\n                  var groupFieldName = series.groupFields[vkey];\n                  var dvalues = dataItem.values[vkey];\n                  if (dvalues) {\n                    var value = dvalues.value;\n                    if (series._adapterO) {\n                      value = series._adapterO.apply(\"groupValue\", {\n                        dataItem: dataItem,\n                        interval: interval,\n                        dataField: vkey,\n                        date: roundedDate,\n                        value: value\n                      }).value;\n                    }\n                    if ($type.isNumber(value)) {\n                      var values = newDataItem.values[vkey];\n                      if (!$type.isNumber(values.open)) {\n                        values.open = value;\n                      }\n                      values.close = value;\n                      if (values.low > value || !$type.isNumber(values.low)) {\n                        values.low = value;\n                      }\n                      if (values.high < value || !$type.isNumber(values.high)) {\n                        values.high = value;\n                      }\n                      if ($type.isNumber(values.sum)) {\n                        values.sum += value;\n                      } else {\n                        values.sum = value;\n                      }\n                      values.count++;\n                      values.average = values.sum / values.count;\n                      if ($type.isNumber(values[groupFieldName])) {\n                        values.value = values[groupFieldName];\n                        values.workingValue = values.value;\n                      }\n                    }\n                  }\n                });\n                $utils.copyProperties(dataItem.properties, newDataItem.properties);\n                $object.each(series.propertyFields, function (key, fieldValue) {\n                  var f = key;\n                  var value = dataItem.properties[key];\n                  if ($type.hasValue(value)) {\n                    newDataItem.hasProperties = true;\n                    newDataItem.setProperty(f, value);\n                  }\n                });\n                newDataItem.groupDataItems.push(dataItem);\n              }\n            }\n          }\n          if (newDataItem) {\n            $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\n          }\n        });\n        if (newDataItem && series._adapterO) {\n          $array.each(dataFields, function (vkey) {\n            newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n              dataItem: newDataItem,\n              interval: interval,\n              dataField: vkey,\n              date: roundedDate,\n              value: newDataItem.values[vkey].value\n            }).value;\n            newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n          });\n        }\n      });\n      this.calculateZoom();\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getDFFormatter = function () {\n    this._df = this.dateFormatter;\n  };\n  /**\r\n   * [postProcessSeriesDataItem description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\n    var _this = this;\n    // we need to do this for all series data items not only added recently, as baseInterval might change\n    var intervalID = \"\";\n    if (interval) {\n      intervalID = interval.timeUnit + interval.count;\n    } else {\n      interval = this.mainBaseInterval;\n    }\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime + intervalID, dataItem);\n    });\n  };\n  /**\r\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n   * elements for them.\r\n   *\r\n   * Can be used to automatically remove strethes without data, like weekends.\r\n   *\r\n   * No, need to call this manually. It will automatically be done if\r\n   * `skipEmptyPeriods = true`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n      if (this._axisBreaks) {\n        this._axisBreaks.clear(); // TODO: what about breaks added by user?\n      }\n      var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var axisBreak = void 0;\n      var _loop_1 = function _loop_1() {\n        $time.add(date, timeUnit, count, this_1._df.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\n        });\n        // open break if not yet opened\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n            this_1._gapBreaks = true;\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n      var this_1 = this;\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n    _super.prototype.fixAxisBreaks.call(this);\n    var axisBreaks = this._axisBreaks;\n    if (axisBreaks) {\n      if (axisBreaks.length > 0) {\n        // process breaks\n        axisBreaks.each(function (axisBreak) {\n          var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n          axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n          var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n          if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n            $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\n          }\n          axisBreak.gridDate = gridDate;\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this._df) {\n      return this._df.firstDayOfWeek;\n    }\n    return 1;\n  };\n  /**\r\n   * [getGridDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param date           [description]\r\n   * @param intervalCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count;\n    // round date\n    $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date);\n    // modify date by adding intervalcount\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\n    // if it's axis break, get first rounded date which is not in a break\n    var axisBreak = this.isInBreak(timestamp);\n    if (axisBreak && axisBreak.endDate) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\n      }\n      timestamp = newDate.getTime();\n    }\n    // get duration between grid lines with break duration removed\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);\n    // calculate how many time units fit to this duration\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\n    // if less units fit, add one and repeat\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n    return newDate;\n  };\n  /**\r\n   * [getBreaklessDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axisBreak  [description]\r\n   * @param timeUnit   [description]\r\n   * @param count      [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    $time.add(date, timeUnit, count, this._df.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n    return date;\n  };\n  /**\r\n   * (Re)validates all Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom();\n      // first regular items\n      var timestamp = this._gridDate.getTime();\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n      var _loop_2 = function _loop_2() {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n        var text = this_2._df.format(date, format);\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        this_2.validateDataElement(dataItem);\n        prevGridDate = date;\n      };\n      var this_2 = this;\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      }\n      // breaks later\n      var renderer_1 = this.renderer;\n      if (this._axisBreaks) {\n        $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n            var intervalCount_1 = axisBreak.gridInterval.count;\n            // only add grid if gap is bigger then minGridDistance\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n              var timestamp_1 = axisBreak.gridDate.getTime();\n              var prevGridDate_1;\n              var count = 0;\n              var _loop_3 = function _loop_3() {\n                var date = $time.copy(axisBreak.gridDate);\n                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\n                count++;\n                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                  var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n                  endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\n                  var format = _this.dateFormats.getKey(timeUnit_1);\n                  if (_this.markUnitChange && prevGridDate_1) {\n                    if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\n                      if (timeUnit_1 !== \"year\") {\n                        format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                      }\n                    }\n                  }\n                  var text_1 = _this._df.format(date, format);\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.text === text_1;\n                  });\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  }\n                  //this.processDataItem(dataItem);\n                  _this.appendDataItem(dataItem);\n                  dataItem.axisBreak = axisBreak;\n                  axisBreak.dataItems.moveValue(dataItem);\n                  dataItem.date = date;\n                  dataItem.endDate = endDate;\n                  dataItem.text = text_1;\n                  prevGridDate_1 = date;\n                  _this.validateDataElement(dataItem);\n                }\n              };\n              while (timestamp_1 <= axisBreak.adjustedMax) {\n                _loop_3();\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates Axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n      dataItem.position = position;\n      var tick = dataItem.tick;\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n      var grid = dataItem.grid;\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n      var fill = dataItem.axisFill;\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n      var mask = dataItem.mask;\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n      if (dataItem.bullet) {\n        renderer.updateBullet(dataItem.bullet, position, endPosition);\n      }\n      var label = dataItem.label;\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\r\n     * A duration in milliseconds of the `baseInterval`.\r\n     *\r\n     * @return Duration (ms)\r\n     */\n    get: function get() {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adjusts min/max values.\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description (review)\r\n   * @param min  Min timestamp\r\n   * @param max  Max timestamp\r\n   * @return Adjusted min/max step\r\n   */\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\r\n   * Adjusts the minimum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\r\n   * Adjusts the maximum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\r\n   * [chooseInterval description]\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description\r\n   * @param index      [description]\r\n   * @param duration   [description]\r\n   * @param gridCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\n    if (!intervals) {\n      intervals = this.gridIntervals;\n    }\n    var gridInterval = intervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = intervals.length - 1;\n    if (index >= lastIndex) {\n      return __assign({}, intervals.getIndex(lastIndex));\n    }\n    var count = Math.ceil(duration / intervalDuration);\n    if (duration < intervalDuration && index > 0) {\n      return __assign({}, intervals.getIndex(index - 1));\n    }\n    if (count <= gridCount) {\n      return __assign({}, intervals.getIndex(index));\n    } else {\n      if (index + 1 < intervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount, intervals);\n      } else {\n        return __assign({}, intervals.getIndex(index));\n      }\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[DateFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n  DateAxis.prototype.formatLabel = function (value) {\n    return this._df.format(value);\n  };\n  /**\r\n   * Converts a Date to an asbolute pixel position within Axis.\r\n   *\r\n   * @param date  Date\r\n   * @return Position (px)\r\n   */\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\r\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n   *\r\n   * @param date  Date or a timestamp\r\n   * @return Relative position\r\n   */\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\r\n   * Converts date to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param date Date\r\n   * @return IOrientationPoint\r\n   */\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\r\n   * Converts pixel position within Axis to a corresponding Date.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Date\r\n   */\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\r\n   * Returns the relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getTimeByLocation description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @param key       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n    var workingValue = dataItem.values[key].workingValue;\n    var value = dataItem.values[key].value;\n    var difference = value - workingValue;\n    startTime -= difference;\n    endTime -= difference;\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n    if ($type.isNumber(this.timezoneOffset)) {\n      date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n    } else if ($type.hasValue(this.timezone)) {\n      date = $time.setTimezone(date, this.timezone);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n      dataItem[\"date\" + axisLetter] = date;\n    }\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime[series.uid];\n    var openTime;\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n    var differece = time - prevSeriesTime;\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n    this._prevSeriesTime[series.uid] = time;\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    }\n  };\n  /**\r\n   * [updateAxisBySeries description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1);\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    }\n    if (baseInterval.timeUnit == \"month\") {\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\n        baseInterval.count = 2;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\n        baseInterval.count = 3;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\n        baseInterval.count = 6;\n      }\n    }\n    // handle daylight saving\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n    this._baseIntervalReal = baseInterval;\n    this._mainBaseInterval = baseInterval;\n    // no need to invalidate\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\r\n     * @return Base interval\r\n     */\n    get: function get() {\n      if (this._groupInterval) {\n        return this._groupInterval;\n      } else if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    /**\r\n     * A base interval (granularity) of data.\r\n     *\r\n     * Used to indicate what are the base units of your data.\r\n     *\r\n     * For example, if you have a data set that has a data point every 5 minutes,\r\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n     *\r\n     * If not set, the Axis will try to determine the setting by its own, looking\r\n     * at actual data.\r\n     *\r\n     * For best results, try to follow these values for `count`:\r\n     *\r\n     * When unit is \"month\", use 12 / count = round number\r\n     * When unit is \"hour\", use 24 / count = round number\r\n     * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n     *\r\n     * @param timeInterval base interval\r\n     */\n    set: function set(timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this._mainBaseInterval = timeInterval;\n        if (!$type.isNumber(timeInterval.count)) {\n          timeInterval.count = 1;\n        }\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\n    /**\r\n     * Indicates granularity of the data of source (unaggregated) data.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Granularity of the main data set\r\n     */\n    get: function get() {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else if (this._mainBaseInterval) {\n        return this._mainBaseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\r\n     * @return Remove empty stretches of time?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n    /**\r\n     * If enabled, axis will automatically collapse empty (without data points)\r\n     * periods of time, i.e. weekends.\r\n     *\r\n     * An \"empty\" period is considered a stretch of time in the length of current\r\n     * `baseInterval` without a single data point in it.\r\n     *\r\n     * For each such empty period, axis will automatically create an\r\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n     * them by accessing `axis.breaks.template`.\r\n     *\r\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n     *\r\n     * Important notes:\r\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n     * * Using this feature affects performance. Use only if you need it.\r\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n     * * Some axis label overlapping might happen.\r\n     * * This setting is not compatible with `groupData = true`.\r\n     *\r\n     * @default false\r\n     * @param value  Remove empty stretches of time?\r\n     */\n    set: function set(value) {\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      } else {\n        if (this._gapBreaks) {\n          this.axisBreaks.clear();\n          this._gapBreaks = false;\n        }\n      }\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n    /**\r\n     * A special date format to apply axis tooltips.\r\n     *\r\n     * Will use same format as for labels, if not set.\r\n     *\r\n     * @param value  Date format\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\r\n     * @return Use different format for period beginning?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n    /**\r\n     * Use `periodChangeDateFormats` to apply different formats to the first\r\n     * label in bigger time unit.\r\n     *\r\n     * @default true\r\n     * @param value  Use different format for period beginning?\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns text to show in a tooltip, based on specific relative position\r\n   * within axis.\r\n   *\r\n   * The label will be formatted as per [[DateFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position\r\n   * @return Label (formatted date)\r\n   */\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    this.tooltipDate = date;\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n      if (dateFormat) {\n        text = this._df.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n    if (!this._adapterO) {\n      return text;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", text);\n    }\n  };\n  /**\r\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position Source position\r\n   * @param location  Location in the cell\r\n   * @return Adjusted position\r\n   */\n  DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this._df.utc);\n    }\n    if (axisLocation > 0 && axisLocation < 1) {\n      date.setTime(date.getTime() + this.baseDuration * axisLocation);\n    }\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this._df.utc);\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n    return this.dateToPosition(date);\n  };\n  /**\r\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell start relative position\r\n   */\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell end relative position\r\n   */\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n    //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\r\n   * Returns a Series data item that corresponds to the specific pixel position\r\n   * of the Axis.\r\n   *\r\n   * If `findNearest` (third parameter) is set to `true`, the method will try\r\n   * to locate nearest available data item if none is found directly under\r\n   * `position`.\r\n   *\r\n   * @param series       Series\r\n   * @param position     Position (px)\r\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n   * @return Data item\r\n   */\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var location = 0.5;\n    if (this.axisLetter == \"Y\") {\n      location = series.dataItems.template.locations.dateY;\n    } else {\n      location = series.dataItems.template.locations.dateX;\n    }\n    var deltaValue = value - location * this.baseDuration;\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (nextDate.getTime() > date.getTime()) {\n      if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\n        date = nextDate;\n      }\n    }\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\n    // todo:  alternatively we can find closiest here\n    if (!dataItem && findNearest) {\n      var key_1;\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n    return dataItem;\n  };\n  /**\r\n   * Returns a formatted date based on position in axis scale.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this._df.format(date, this.getCurrentLabelFormat());\n  };\n  /**\r\n   * Returns label date format based on currently used time units\r\n   *\r\n   * @return Format\r\n   */\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\r\n   * Initializes an Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n    var renderer = this.renderer;\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function get() {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.animateMinMax = function (min, max) {\n    var _this = this;\n    var animation = this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n    animation.events.on(\"animationprogress\", function () {\n      _this.dispatch(\"extremeschanged\");\n    });\n    return animation;\n  };\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n  DateAxis.prototype.handleExtremesChange = function () {\n    _super.prototype.handleExtremesChange.call(this);\n    if (this.groupData) {\n      var id = this.baseInterval.timeUnit + this.baseInterval.count;\n      this.groupMin[id] = this._finalMin;\n      this.groupMax[id] = this._finalMax;\n    }\n  };\n  /**\r\n   * Zooms axis to specific Dates.\r\n   *\r\n   * @param startDate       Start date\r\n   * @param endValue        End date\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\n    startDate = this._df.parse(startDate);\n    endDate = this._df.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\n    var _this = this;\n    if (!this.groupData) {\n      //let start: number = (startValue - this.min) / (this.max - this.min);\n      //let end: number = (endValue - this.min) / (this.max - this.min);\n      var start = this.valueToPosition(startValue);\n      var end = this.valueToPosition(endValue);\n      this.zoom({\n        start: start,\n        end: end\n      }, skipRangeEvent, instantly);\n    } else {\n      var difference = this.adjustDifference(startValue, endValue);\n      var isEnd = false;\n      if (endValue == this.max) {\n        isEnd = true;\n      }\n      var isStart = false;\n      if (startValue == this.min) {\n        isStart = true;\n      }\n      if ($type.hasValue(difference)) {\n        var mainBaseInterval = this.mainBaseInterval;\n        var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\n        if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\n          groupInterval_1 = __assign({}, mainBaseInterval);\n        }\n        var id = groupInterval_1.timeUnit + groupInterval_1.count;\n        var min_1 = this.groupMin[id];\n        var max_1 = this.groupMax[id];\n        if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\n          min_1 = Number.POSITIVE_INFINITY;\n          max_1 = Number.NEGATIVE_INFINITY;\n          this.series.each(function (series) {\n            var seriesMin = series.min(_this);\n            var seriesMax = series.max(_this);\n            if (series._dataSets) {\n              var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\n              if (ds) {\n                var mindi = ds.getIndex(0);\n                var maxdi = ds.getIndex(ds.length - 1);\n                if (mindi) {\n                  if (series.xAxis == _this) {\n                    seriesMin = mindi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMin = mindi.dateY.getTime();\n                  }\n                }\n                if (maxdi) {\n                  if (series.xAxis == _this) {\n                    seriesMax = maxdi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMax = maxdi.dateY.getTime();\n                  }\n                }\n              }\n            }\n            seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n            if (seriesMin < min_1) {\n              min_1 = seriesMin;\n            }\n            if (seriesMax > max_1) {\n              max_1 = seriesMax;\n            }\n          });\n          this.groupMin[id] = min_1;\n          this.groupMax[id] = max_1;\n        }\n        startValue = $math.fitToRange(startValue, min_1, max_1);\n        endValue = $math.fitToRange(endValue, min_1, max_1);\n        if (adjust) {\n          if (isEnd) {\n            startValue = endValue - difference;\n            startValue = $math.fitToRange(startValue, min_1, max_1);\n          }\n          if (isStart) {\n            endValue = startValue + difference;\n            endValue = $math.fitToRange(endValue, min_1, max_1);\n          }\n        }\n        var start = (startValue - min_1) / (max_1 - min_1);\n        var end = (endValue - min_1) / (max_1 - min_1);\n        this.zoom({\n          start: start,\n          end: end\n        }, skipRangeEvent, instantly);\n      }\n    }\n  };\n  /**\r\n   * Adds `baseInterval` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n  DateAxis.prototype.copyFrom = function (source) {\n    var _this = this;\n    _super.prototype.copyFrom.call(this, source);\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n    this.groupIntervals.clear();\n    source.groupIntervals.each(function (interval) {\n      _this.groupIntervals.push(__assign({}, interval));\n    });\n    this.gridIntervals.clear();\n    source.gridIntervals.each(function (interval) {\n      _this.gridIntervals.push(__assign({}, interval));\n    });\n    if (source._baseInterval) {\n      this.baseInterval = source._baseInterval;\n    }\n  };\n  /**\r\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n   *\r\n   * @param position Position (0-1)\r\n   * @param local or global position\r\n   */\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n    if (this.snapTooltip) {\n      // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\n      var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n          if (dataItem) {\n            var date = void 0;\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n        closestTime_1 = closestDate_1.getTime();\n        var tooltipLocation = this.renderer.tooltipLocation;\n        if (tooltipLocation == 0) {\n          tooltipLocation = 0.0001;\n        }\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n        if (this.chart.cursor && this.chart.cursor.snapToSeries) {\n          //void\n        } else {\n          this.series.each(function (series) {\n            var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\n            var point = series.showTooltipAtDataItem(dataItem);\n            if (point) {\n              _this.chart._seriesPoints.push({\n                series: series,\n                point: point\n              });\n            } else {\n              // check, otherwise column tooltip will be hidden\n              if (series.tooltipText || series.tooltipHTML) {\n                series.hideTooltip();\n              }\n            }\n          });\n        }\n        //this.chart.sortSeriesTooltips(seriesPoints);\n      }\n    }\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position.\r\n     *\r\n     * @default true\r\n     * @param value  Should snap?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupData\", {\n    /**\r\n     * @return Group data points?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupData\");\n    },\n    /**\r\n     * Indicates if data should be aggregated to composide data items if there\r\n     * are more data items in selected range than `groupCount`.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n     *\r\n     * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n     * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n     *\r\n     * The group intervals to aggregate data to is defined by `groupIntervals`\r\n     * property.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     * @param  value  Group data points?\r\n     */\n    set: function set(value) {\n      var _this = this;\n      if (this.setPropertyValue(\"groupData\", value)) {\n        this.series.each(function (series) {\n          series.setDataSet(\"\");\n          if (value && !series.dataGrouped && series.inited) {\n            series._baseInterval[_this.uid] = _this.mainBaseInterval;\n            _this.groupSeriesData(series);\n          }\n        });\n        this._currentDataSetId = \"\";\n        this._groupInterval = undefined;\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\n    /**\r\n     * @return Interval\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupInterval\");\n    },\n    /**\r\n     * Disables automatic selection of data grouping intervals and always uses\r\n     * `groupInterval` if set. Works only if `groupData = true`.\r\n     *\r\n     * @since 4.9.24\r\n     * @param  value  Interval\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"groupInterval\", value)) {\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupCount\", {\n    /**\r\n     * @return Number of data items\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupCount\");\n    },\n    /**\r\n     * Indicates threshold of data items in selected range at which to start\r\n     * aggregating data items if `groupData = true`.\r\n     *\r\n     * @default 200\r\n     * @since 4.7.0\r\n     * @param  value  Number of data items\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"groupCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\n    /**\r\n     * @todo Timezone offset in minutes\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"timezoneOffset\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data by applying specific offset\r\n     * in minutes.\r\n     *\r\n     * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n     * will skew your results by applying offset twice.\r\n     *\r\n     * @since 4.8.5\r\n     * @param  value Time zone offset in minutes\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"timezoneOffset\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"timezone\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data to specific named timezone,\r\n     * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n     *\r\n     * IMPORTANT: it is no longer recommended to use this setting. Please\r\n     * set`timezone` on `dateFormatter`.\r\n     *\r\n     * @deprecated\r\n     * @since 4.10.1\r\n     * @param  value Time zone\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"timezone\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\r\n     * Current grid interval.\r\n     *\r\n     * @return Grid interval\r\n     */\n    get: function get() {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var date = dataItem.dates[\"date\" + this.axisLetter];\n          var prevDate = previous.dates[\"date\" + this.axisLetter];\n          if (date && prevDate) {\n            var time = date.getTime();\n            var prevTime = prevDate.getTime();\n            if (time - prevTime > series.autoGapCount * this.baseDuration) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function get() {\n      return this.min;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  DateAxis.prototype._saveMinMax = function (min, max) {\n    var groupInterval = this.groupInterval;\n    if (!groupInterval) {\n      groupInterval = this.mainBaseInterval;\n    }\n    var id = groupInterval.timeUnit + groupInterval.count;\n    this._intervalMin[id] = min;\n    this._intervalMax[id] = max;\n  };\n  return DateAxis;\n}(ValueAxis);\nexport { DateAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"names":["ValueAxis","ValueAxisDataItem","List","Dictionary","DateAxisBreak","registry","$time","$type","$iter","$math","$array","$object","$utils","OrderedListTemplate","DateAxisDataItem","_super","__extends","_this","call","className","applyTheme","values","date","endDate","Object","defineProperty","prototype","get","dates","set","setDate","value","getTime","endValue","DateAxis","_gapBreaks","gridIntervals","groupIntervals","dateFormats","periodChangeDateFormats","_baseIntervalReal","timeUnit","count","_prevSeriesTime","_minDifference","_firstWeekDay","groupMin","groupMax","_intervalMax","_intervalMin","setPropertyValue","snapTooltip","tooltipPosition","groupCount","events","on","getDFFormatter","pushAll","axisFieldName","fillRule","dataItem","axis","component","gridInterval","_gridInterval","gridDuration","getDuration","Math","round","min","axisFill","__disabled","applyInternalDefaults","hasKey","setKey","language","translate","createDataItem","createAxisBreak","validateDataItems","start","end","baseDuration","periodCount","max","getFirstWeekDay","mainBaseDuration","mainBaseInterval","maxZoomFactor","_deltaMinMax","newPeriodCount","zoom","handleSelectionExtremesChange","getIntervalMax","interval","getIntervalMin","calculateZoom","difference","adjustDifference","_minZoomed","_maxZoomed","dataSetChanged","groupData","hasValue","selectionMin","selectionMax","diff","modifiedDifference","startLocation","endLocation","groupInterval","__assign","chooseInterval","_groupInterval","newId","_currentDataSetId","dispatch","series","each","baseAxis","setDataSet","_gridCount","baseInterval","_nextGridUnit","getNextUnit","_intervalDuration","_gridDate","Date","minZoomed","_df","utc","timezoneMinutes","timezone","iterator","field_1","getAxisField","undefined","minZoomedStr","toString","startDataItem","dataItemsByAxis","getKey","uid","currentDataSetId","startIndex","findFirst","index","dataItems","findClosestIndex","x","maxZoomed","add","maxZoomedStr","endDataItem","endIndex","length","outOfRange","dataRangeInvalid","validateDataRange","time","key","previousDataItem","getIndex","previousDate","validateData","isNumber","minDifference","Number","MAX_VALUE","seriesDataChangeUpdate","postProcessSeriesDataItems","seriesGroupUpdate","addEmptyUnitsBreaks","JSON","stringify","_baseInterval","mainDataSet","postProcessSeriesDataItem","groupSeriesData","dataGrouped","bulletsContainer","removeChildren","intervals_1","mainIntervalDuration_1","intervalDuration","push","_dataSets","dispose","clear","axisLetter","dataSetId","dataSet","template","clone","dataSets","previousTime","NEGATIVE_INFINITY","i","newDataItem","dataFields","dfkey","df","dfk","indexOf","roundedDate","getDate","firstDayOfWeek","currentTime","_adapterO","vkey","apply","dataField","workingValue","create","dataContext","setWorkingLocation","locations","dateX","openDateX","dateY","openDateY","_index","dvalues","open","close","low","high","sum","average","propertyFields","fieldValue","f","properties","hasProperties","setProperty","groupDataItems","groupFieldName","groupFields","copyProperties","dateFormatter","intervalID","startDate","startTime","setCalculatedValue","skipEmptyPeriods","_axisBreaks","axisBreak","this_1","startTimeStr","hasData","contains","axisBreaks","fixAxisBreaks","breakGridCount","ceil","endPosition","startPosition","adjustedEndValue","adjustedStartValue","gridDate","getGridDate","intervalCount","realIntervalCount","prevTimestamp","newDate","copy","timestamp","isInBreak","durationBreaksRemoved","countBreaksRemoved","getBreaklessDate","validateAxisElements","prevGridDate","dataItemsIterator_1","_dataItemsIterator","resetIterators","this_2","format","markUnitChange","checkChange","text","find","appendDataItem","validateDataElement","renderer_1","renderer","breakSize","timeUnit_1","intervalCount_1","getDistance","startPoint","endPoint","minGridDistance","timestamp_1","prevGridDate_1","text_1","moveValue","adjustedMax","itemIndex","_axisItemCount","endTimestamp","position","valueToPosition","fillEndPosition","isRange","tick","disabled","updateTickElement","grid","updateGridElement","fill","updateFillElement","mask","bullet","updateBullet","label","location_1","location","updateLabelElement","adjustMinMax","step","fixMin","endTime","fixMax","duration","gridCount","intervals","lastIndex","formatLabel","dateToPosition","anyToPosition","dateToPoint","point","positionToPoint","angle","positionToAngle","y","anyToPoint","valueToPoint","positionToDate","positionToValue","getPositionX","stackKey","range","getTimeByLocation","baseValue","fitToRange","getPositionY","stack","getValue","getAngle","workingLocations","processSeriesDataItem","timezoneOffset","setTime","getTimezoneOffset","setValue","setTimezone","openDate","prevSeriesTime","openTime","abs","differece","updateAxisBySeries","_mainBaseInterval","timeInterval","invalidate","getPropertyValue","breakTemplate","startLine","endLine","fillShape","invalidateSeries","invalidateData","getTooltipText","tooltipDate","tooltipDateFormat","dateFormat","getPositionLabel","roundPosition","axisLocation","getCellStartPosition","getCellEndPosition","getSeriesDataItem","findNearest","deltaValue","nextDate","key_1","Infinity","getCurrentLabelFormat","initRenderer","ticks","labels","baseGrid","animateMinMax","animation","animate","property","from","_minAdjusted","to","_maxAdjusted","rangeChangeDuration","rangeChangeEasing","handleExtremesChange","id","_finalMin","_finalMax","zoomToDates","skipRangeEvent","instantly","adjust","parse","zoomToValues","startValue","isEnd","isStart","groupInterval_1","min_1","max_1","POSITIVE_INFINITY","seriesMin","seriesMax","ds","mindi","maxdi","xAxis","yAxis","asIs","field","copyFrom","source","showTooltipAtPosition","local","toAxisPosition","actualDate","actualTime_1","closestDate_1","closestTime_1","tooltipLocation","chart","cursor","snapToSeries","showTooltipAtDataItem","_seriesPoints","tooltipText","tooltipHTML","hideTooltip","inited","makeGap","previous","connect","autoGapCount","prevDate","prevTime","_saveMinMax","registeredClasses"],"sources":["../../../../../src/.internal/charts/axes/DateAxis.ts"],"sourcesContent":["/**\r\n * DateAxis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem, IValueAxisProperties, IValueAxisDataFields, IValueAxisAdapters, IValueAxisEvents } from \"./ValueAxis\";\r\nimport { AxisItemLocation } from \"./Axis\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Grid } from \"./Grid\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { LineSeriesDataItem } from \"../series/LineSeries\";\r\nimport { TimeUnit } from \"../../core/defs/TimeUnit\";\r\nimport { ITimeInterval } from \"../../core/defs/ITimeInterval\";\r\nimport { IMinMaxStep } from \"./ValueAxis\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\nimport { DateFormatter } from \"../../core/formatters/DateFormatter\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class DateAxisDataItem extends ValueAxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: DateAxis;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxisDataItem\";\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.values.date = {};\r\n\t\tthis.values.endDate = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Date position of the data item.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set date(date: Date) {\r\n\t\tthis.setDate(\"date\", date);\r\n\t\tthis.value = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get date(): Date {\r\n\t\treturn this.dates[\"date\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * End date for data item.\r\n\t *\r\n\t * @param date End date\r\n\t */\r\n\tpublic set endDate(date: Date) {\r\n\t\tthis.setDate(\"endDate\", date);\r\n\t\tthis.endValue = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return End date\r\n\t */\r\n\tpublic get endDate(): Date {\r\n\t\treturn this.dates[\"endDate\"];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[DateAxis]].\r\n */\r\nexport interface IDateAxisDataFields extends IValueAxisDataFields {\r\n\r\n\t/**\r\n\t * Date.\r\n\t */\r\n\tdate?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[DateAxis]].\r\n */\r\nexport interface IDateAxisProperties extends IValueAxisProperties {\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tskipEmptyPeriods?: boolean;\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tmarkUnitChange?: boolean;\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tsnapTooltip?: boolean;\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t */\r\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupData?: boolean;\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupCount?: number;\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t */\r\n\tgroupInterval?: ITimeInterval;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t *\r\n\t * @since 4.8.5\r\n\t */\r\n\ttimezoneOffset?: number;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: do not set `timezone` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying timezone twice.\r\n\t * \r\n\t * @since 4.10.1\r\n\t */\r\n\ttimezone?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[DateAxis]].\r\n */\r\nexport interface IDateAxisEvents extends IValueAxisEvents {\r\n\t/**\r\n\t * Invoked when data grouping is on and grouping period is changed. You can find our the period via dateAxis.currentDataSetId property.\r\n\t */\r\n\tgroupperiodchanged: IDateAxisEvents;\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DateAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IDateAxisAdapters extends IValueAxisAdapters, IDateAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\r\nexport class DateAxis<T extends AxisRenderer = AxisRenderer> extends ValueAxis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: IDateAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IDateAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IDateAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IDateAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: DateAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: DateAxisBreak;\r\n\r\n\tprotected _gapBreaks: boolean = false;\r\n\r\n\t/**\r\n\t * A list of date/time intervals for Date axis.\r\n\t *\r\n\t * This define various granularities available for the axis. For example\r\n\t * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n\t * the axis will choose the granularity of 10 minutes, displaying a label\r\n\t * every 10 minutes.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *  { timeUnit: \"millisecond\", count: 1 },\r\n\t *  { timeUnit: \"millisecond\", count: 5 },\r\n\t *  { timeUnit: \"millisecond\", count: 10 },\r\n\t *  { timeUnit: \"millisecond\", count: 50 },\r\n\t *  { timeUnit: \"millisecond\", count: 100 },\r\n\t *  { timeUnit: \"millisecond\", count: 500 },\r\n\t *  { timeUnit: \"second\", count: 1 },\r\n\t *  { timeUnit: \"second\", count: 5 },\r\n\t *  { timeUnit: \"second\", count: 10 },\r\n\t *  { timeUnit: \"second\", count: 30 },\r\n\t *  { timeUnit: \"minute\", count: 1 },\r\n\t *  { timeUnit: \"minute\", count: 5 },\r\n\t *  { timeUnit: \"minute\", count: 10 },\r\n\t *  { timeUnit: \"minute\", count: 30 },\r\n\t *  { timeUnit: \"hour\", count: 1 },\r\n\t *  { timeUnit: \"hour\", count: 3 },\r\n\t *  { timeUnit: \"hour\", count: 6 },\r\n\t *  { timeUnit: \"hour\", count: 12 },\r\n\t *  { timeUnit: \"day\", count: 1 },\r\n\t *  { timeUnit: \"day\", count: 2 },\r\n\t *  { timeUnit: \"day\", count: 3 },\r\n\t *  { timeUnit: \"day\", count: 4 },\r\n\t *  { timeUnit: \"day\", count: 5 },\r\n\t *  { timeUnit: \"week\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 2 },\r\n\t *  { timeUnit: \"month\", count: 3 },\r\n\t *  { timeUnit: \"month\", count: 6 },\r\n\t *  { timeUnit: \"year\", count: 1 },\r\n\t *  { timeUnit: \"year\", count: 2 },\r\n\t *  { timeUnit: \"year\", count: 5 },\r\n\t *  { timeUnit: \"year\", count: 10 },\r\n\t *  { timeUnit: \"year\", count: 50 },\r\n\t *  { timeUnit: \"year\", count: 100 }\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\tpublic gridIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n\t * chart will try to aggregate data items into grouped data items.\r\n\t *\r\n\t * If there are more data items in selected period than `groupCount`, it will\r\n\t * group data items into bigger period.\r\n\t *\r\n\t * For example seconds might be grouped into 10-second aggregate data items.\r\n\t *\r\n\t * This setting indicates what group intervals can the chart group to.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { timeUnit: \"millisecond\", count: 1},\r\n\t *   { timeUnit: \"millisecond\", count: 10 },\r\n\t *   { timeUnit: \"millisecond\", count: 100 },\r\n\t *   { timeUnit: \"second\", count: 1 },\r\n\t *   { timeUnit: \"second\", count: 10 },\r\n\t *   { timeUnit: \"minute\", count: 1 },\r\n\t *   { timeUnit: \"minute\", count: 10 },\r\n\t *   { timeUnit: \"hour\", count: 1 },\r\n\t *   { timeUnit: \"day\", count: 1 },\r\n\t *   { timeUnit: \"week\", count: 1 },\r\n\t *   { timeUnit: \"month\", count: 1 },\r\n\t *   { timeUnit: \"year\", count: 1 }\r\n\t * ]\r\n\t * ```\r\n\t * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n\t * \r\n\t * @since 4.7.0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t */\r\n\tpublic groupIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * A collection of date formats to use when formatting different time units\r\n\t * on Date/time axis.\r\n\t *\r\n\t * Actual defaults will depend on the language locale set for the chart.\r\n\t *\r\n\t * To override format for a specific time unit, say days, you need to set\r\n\t * the appropriate key to a format string. E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JSON\r\n\t * \"xAxes\": [{\r\n\t *   \"type\": \"DateAxis\",\r\n\t *   \"dateFormats\": {\r\n\t *     \"day\": \"MMMM d, yyyy\"\r\n\t *   }\r\n\t * }]\r\n\t * ```\r\n\t *\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tpublic dateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * These formats are applied to labels that are first in a larger unit.\r\n\t *\r\n\t * For example, if we have a DateAxis with days on it, the first day of month\r\n\t * indicates a break in month - a start of the bigger period.\r\n\t *\r\n\t * For those labels, `periodChangeDateFormats` are applied instead of\r\n\t * `dateFormats`.\r\n\t *\r\n\t * This allows us implement convenient structures, like instead of:\r\n\t *\r\n\t * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n\t *\r\n\t * We can have:\r\n\t *\r\n\t * `Jan - 1 - 2 - 3 - ...`\r\n\t *\r\n\t * This can be disabled by setting `markUnitChange = false`.\r\n\t */\r\n\tpublic periodChangeDateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * At which intervals grid elements are displayed.\r\n\t */\r\n\tprotected _gridInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * [_intervalDuration description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _intervalDuration: number;\r\n\r\n\t/**\r\n\t * [_gridDate description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _gridDate: Date;\r\n\r\n\t/**\r\n\t * [_nextGridUnit description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _nextGridUnit: TimeUnit;\r\n\r\n\t/**\r\n\t * User-defined granularity of data.\r\n\t */\r\n\tprotected _baseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the main data set.\r\n\t */\r\n\tprotected _mainBaseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the currently selected data set.\r\n\t */\r\n\tprotected _groupInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * Actual interval (granularity) derived from the actual data.\r\n\t */\r\n\tprotected _baseIntervalReal: ITimeInterval = { timeUnit: \"day\", count: 1 };\r\n\r\n\t/**\r\n\t */\r\n\tprotected _prevSeriesTime: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * [_minDifference description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _minDifference: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A function which applies fills to axis cells.\r\n\t *\r\n\t * Default function fills every second fill. You can set this to a function\r\n\t * that follows some other logic.\r\n\t *\r\n\t * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n\t * property accordingly.\r\n\t */\r\n\tpublic fillRule(dataItem: this[\"_dataItem\"]): void {\r\n\t\tlet value = dataItem.value;\r\n\t\tlet axis = dataItem.component;\r\n\t\tlet gridInterval = axis._gridInterval;\r\n\t\tlet gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tif (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n\t\t\tdataItem.axisFill.__disabled = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.axisFill.__disabled = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _firstWeekDay: number = 1;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _df: DateFormatter;\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' min timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMin: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' max timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMax: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * Date of the last shown axis tooltip.\r\n\t *\r\n\t * @since 4.9.7\r\n\t * @readonly\r\n\t */\r\n\tpublic tooltipDate: Date;\r\n\r\n\r\n\tprotected _intervalMax: { [index: string]: number } = {};\r\n\tprotected _intervalMin: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxis\";\r\n\r\n\t\tthis.setPropertyValue(\"markUnitChange\", true);\r\n\t\tthis.snapTooltip = true;\r\n\t\tthis.tooltipPosition = \"pointer\";\r\n\r\n\t\tthis.setPropertyValue(\"groupData\", false);\r\n\t\tthis.groupCount = 200;\r\n\r\n\t\tthis.events.on(\"parentset\", this.getDFFormatter, this, false);\r\n\r\n\t\t// Translatable defaults are applied in `applyInternalDefaults()`\r\n\t\t// ...\r\n\r\n\t\t// Define default intervals\r\n\t\tthis.gridIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 5 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 50 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 500 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 5 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"second\", count: 30 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 5 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 15 },\r\n\t\t\t{ timeUnit: \"minute\", count: 30 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"hour\", count: 3 },\r\n\t\t\t{ timeUnit: \"hour\", count: 6 },\r\n\t\t\t{ timeUnit: \"hour\", count: 12 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 2 },\r\n\t\t\t{ timeUnit: \"day\", count: 3 },\r\n\t\t\t{ timeUnit: \"day\", count: 4 },\r\n\t\t\t{ timeUnit: \"day\", count: 5 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 2 },\r\n\t\t\t{ timeUnit: \"month\", count: 3 },\r\n\t\t\t{ timeUnit: \"month\", count: 6 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 2 },\r\n\t\t\t{ timeUnit: \"year\", count: 5 },\r\n\t\t\t{ timeUnit: \"year\", count: 10 },\r\n\t\t\t{ timeUnit: \"year\", count: 50 },\r\n\t\t\t{ timeUnit: \"year\", count: 100 },\r\n\t\t\t{ timeUnit: \"year\", count: 200 },\r\n\t\t\t{ timeUnit: \"year\", count: 500 },\r\n\t\t\t{ timeUnit: \"year\", count: 1000 },\r\n\t\t\t{ timeUnit: \"year\", count: 2000 },\r\n\t\t\t{ timeUnit: \"year\", count: 5000 },\r\n\t\t\t{ timeUnit: \"year\", count: 10000 },\r\n\t\t\t{ timeUnit: \"year\", count: 100000 }\r\n\t\t]);\r\n\r\n\t\tthis.groupIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 }\r\n\t\t]);\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"date\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Set default date formats\r\n\t\tif (!this.dateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\t // not a mistake\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"year\")) {\r\n\t\t\tthis.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new DateAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new DateAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis' data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems(): void {\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet start: number = this.start;\r\n\t\tlet end: number = this.end;\r\n\t\tlet baseDuration = this.baseDuration;\r\n\t\tlet periodCount: number = (this.max - this.min) / baseDuration;\r\n\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tthis.getDFFormatter();\r\n\r\n\t\tsuper.validateDataItems();\r\n\r\n\t\tlet mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count)\r\n\r\n\t\tthis.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\r\n\r\n\t\tthis._deltaMinMax = this.baseDuration / 2;\r\n\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet newPeriodCount: number = (this.max - this.min) / baseDuration;\r\n\t\tstart = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n\t\tthis.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n\t}\r\n\r\n\t/**\r\n\t * Handles process after zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Does nothing?\r\n\t */\r\n\tpublic handleSelectionExtremesChange(): void {\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getIntervalMax(interval: ITimeInterval): number {\r\n\t\treturn this._intervalMax[interval.timeUnit + interval.count];\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getIntervalMin(interval: ITimeInterval): number {\r\n\t\treturn this._intervalMin[interval.timeUnit + interval.count];\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all positions, related to axis as per current zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic calculateZoom(): void {\r\n\t\tsuper.calculateZoom();\r\n\r\n\t\tlet difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\r\n\t\tlet dataSetChanged = false;\r\n\r\n\t\t// if data has to be grouped, choose interval and set dataset\r\n\t\tif (this.groupData && $type.hasValue(difference)) {\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\r\n\t\t\tconst min = this.getIntervalMin(mainBaseInterval);\r\n\t\t\tconst max = this.getIntervalMax(mainBaseInterval);\r\n\r\n\t\t\tlet selectionMin = min + (max - min) * this.start;\r\n\t\t\tlet selectionMax = min + (max - min) * this.end;\r\n\t\t\tlet diff = this.adjustDifference(selectionMin, selectionMax);\r\n\r\n\t\t\tlet modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\r\n\r\n\t\t\tlet groupInterval: ITimeInterval;\r\n\t\t\tif (this.groupInterval) {\r\n\t\t\t\tgroupInterval = { ...this.groupInterval }\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tgroupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\r\n\r\n\t\t\t\tif ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis._groupInterval = groupInterval;\r\n\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\tif (this._currentDataSetId != newId) {\r\n\t\t\t\tthis._currentDataSetId = newId;\r\n\t\t\t\tthis.dispatch(\"groupperiodchanged\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tif (series.setDataSet(this._currentDataSetId)) {\r\n\t\t\t\t\t\tdataSetChanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = this.chooseInterval(0, difference, this._gridCount);\r\n\r\n\t\tif ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n\t\t\tgridInterval = { ...this.baseInterval };\r\n\t\t}\r\n\r\n\t\tthis._gridInterval = gridInterval;\r\n\t\tthis._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n\r\n\t\t// the following is needed to avoid grid flickering while scrolling\r\n\t\tthis._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\t\tthis._gridDate = $time.round(\r\n\t\t\tnew Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)),\r\n\t\t\tgridInterval.timeUnit,\r\n\t\t\tgridInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\t// tell series start/end\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\tlet field = <keyof XYSeriesDataItem>series.getAxisField(this);\r\n\r\n\t\t\t\tlet minZoomed = $time.round(\r\n\t\t\t\t\tnew Date(this._minZoomed + this.baseDuration * 0.05),\r\n\t\t\t\t\tthis.baseInterval.timeUnit, this.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t).getTime();\r\n\t\t\t\tlet minZoomedStr = minZoomed.toString();\r\n\t\t\t\tlet startDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(minZoomedStr + series.currentDataSetId);\r\n\r\n\t\t\t\tlet startIndex: number = 0;\r\n\t\t\t\tif (this.start != 0) {\r\n\t\t\t\t\tif (startDataItem) {\r\n\t\t\t\t\t\tstartDataItem = this.findFirst(startDataItem, minZoomed, field);\r\n\t\t\t\t\t\tstartIndex = startDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstartIndex = series.dataItems.findClosestIndex(this._minZoomed, (x) => <number>x[field], \"left\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n\t\t\t\tlet baseInterval = this.baseInterval;\r\n\t\t\t\tlet maxZoomed = $time.add(\r\n\t\t\t\t\t$time.round(\r\n\t\t\t\t\t\tnew Date(this._maxZoomed),\r\n\t\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t),\r\n\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\tthis._df.utc\r\n\t\t\t\t).getTime();\r\n\r\n\t\t\t\tlet maxZoomedStr = maxZoomed.toString();\r\n\t\t\t\tlet endDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(maxZoomedStr + series.currentDataSetId);\r\n\t\t\t\tlet endIndex: number = series.dataItems.length;\r\n\t\t\t\tif (this.end != 1) {\r\n\t\t\t\t\tif (endDataItem) {\r\n\t\t\t\t\t\tendIndex = endDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tmaxZoomed -= 1;\r\n\t\t\t\t\t\tendIndex = series.dataItems.findClosestIndex(maxZoomed, (x) => <number>x[field], \"right\");\r\n\t\t\t\t\t\t// not good - if end is in the gap, indexes go like 5,4,3,4,2,1\r\n\t\t\t\t\t\t//if (endIndex < series.dataItems.length) {\r\n\t\t\t\t\t\tendIndex++;\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.max(this) < minZoomed) {\r\n\t\t\t\t\tseries.startIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.endIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if (series.min(this) > maxZoomed) {\r\n\t\t\t\t\tseries.startIndex = 0;\r\n\t\t\t\t\tseries.endIndex = 0;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.outOfRange = false;\r\n\t\t\t\t\tseries.startIndex = startIndex;\r\n\t\t\t\t\tseries.endIndex = endIndex;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\tconsole.log(series.name, startIndex, endIndex);\r\n\r\n\t\t\t\tif (!dataSetChanged && series.dataRangeInvalid) {\r\n\t\t\t\t\tseries.validateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprotected findFirst(dataItem: XYSeriesDataItem, time: number, key: string): XYSeriesDataItem {\r\n\t\tlet index = dataItem.index;\r\n\r\n\t\tif (index > 0) {\r\n\t\t\tlet series = dataItem.component;\r\n\t\t\tlet previousDataItem = series.dataItems.getIndex(index - 1);\r\n\r\n\t\t\tlet previousDate = (<any>previousDataItem)[key];\r\n\r\n\t\t\tif (!previousDate || previousDate.getTime() < time) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.findFirst(previousDataItem, time, key);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn dataItem;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tsuper.validateData();\r\n\t\tif (!$type.isNumber(this.baseInterval.count)) {\r\n\t\t\tthis.baseInterval.count = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get minDifference(): number {\r\n\t\tlet minDifference = Number.MAX_VALUE;\r\n\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (minDifference > this._minDifference[series.uid]) {\r\n\t\t\t\tminDifference = this._minDifference[series.uid];\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n\t\t\tminDifference = $time.getDuration(\"day\");\r\n\t\t}\r\n\r\n\t\treturn minDifference;\r\n\t}\r\n\r\n\t/**\r\n\t * [dataChangeUpdate description]\r\n\t *\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic seriesDataChangeUpdate(series: XYSeries): void {\r\n\t\tthis._minDifference[series.uid] = Number.MAX_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItems description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic postProcessSeriesDataItems(series?: XYSeries): void {\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tif (series) {\r\n\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.addEmptyUnitsBreaks();\r\n\t}\r\n\r\n\tprotected seriesGroupUpdate(series: XYSeries) {\r\n\t\tif (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\r\n\r\n\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\r\n\t\t\tseries.mainDataSet.each((dataItem) => {\r\n\t\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t\t});\r\n\r\n\t\t\tif (this.groupData) {\r\n\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates series group data.\r\n\t * \r\n\t * @param  series  Series\r\n\t * @ignore\r\n\t */\r\n\tpublic groupSeriesData(series: XYSeries): void {\r\n\t\tif (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\r\n\r\n\t\t\tseries.bulletsContainer.removeChildren();\r\n\r\n\t\t\t// make array of intervals which will be used;\r\n\t\t\tlet intervals: ITimeInterval[] = [];\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\tlet mainIntervalDuration = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\r\n\r\n\t\t\tthis.groupIntervals.each((interval) => {\r\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\r\n\t\t\t\tif ((intervalDuration > mainIntervalDuration && intervalDuration < (this.max - this.min)) || this.groupInterval) {\r\n\t\t\t\t\tintervals.push(interval);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (series._dataSets) {\r\n\t\t\t\tseries._dataSets.each((key, dataItems) => {\r\n\t\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\t\tdataItem.dispose();\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdataItems.clear();\r\n\t\t\t\t})\r\n\t\t\t\tseries._dataSets.clear();\r\n\t\t\t}\r\n\r\n\t\t\tseries.dataGrouped = true;\r\n\r\n\t\t\t$array.each(intervals, (interval) => {\r\n\r\n\t\t\t\t//let mainBaseInterval = this._mainBaseInterval;\r\n\t\t\t\tlet key = \"date\" + this.axisLetter;\r\n\r\n\t\t\t\t// create data set\r\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\r\n\t\t\t\t// todo: check where this clone goes\r\n\t\t\t\tlet dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\r\n\r\n\t\t\t\tseries.dataSets.setKey(dataSetId, dataSet);\r\n\r\n\t\t\t\tlet dataItems = series.mainDataSet;\r\n\t\t\t\tlet previousTime: number = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tlet newDataItem: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet dataFields: string[] = [];\r\n\r\n\t\t\t\t$object.each(series.dataFields, (dfkey, df) => {\r\n\t\t\t\t\tlet dfk = <string>dfkey;\r\n\t\t\t\t\tif (dfk != key && dfk.indexOf(\"Show\") == -1) {\r\n\t\t\t\t\t\tdataFields.push(dfk);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\tlet roundedDate: Date;\r\n\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\tlet date = dataItem.getDate(key);\r\n\t\t\t\t\tif (date) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\troundedDate = $time.round(\r\n\t\t\t\t\t\t\tnew Date(time),\r\n\t\t\t\t\t\t\tinterval.timeUnit,\r\n\t\t\t\t\t\t\tinterval.count,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tlet currentTime = roundedDate.getTime();\r\n\t\t\t\t\t\t// changed period\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (previousTime < currentTime) {\r\n\r\n\t\t\t\t\t\t\tif (newDataItem && series._adapterO) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnewDataItem = dataSet.create();\r\n\r\n\t\t\t\t\t\t\tnewDataItem.dataContext = {};\r\n\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\r\n\r\n\t\t\t\t\t\t\tnewDataItem.component = series;\r\n\t\t\t\t\t\t\t// other Dates?\r\n\t\t\t\t\t\t\tnewDataItem.setDate(key, roundedDate);\r\n\t\t\t\t\t\t\tnewDataItem._index = i;\r\n\t\t\t\t\t\t\ti++;\r\n\r\n\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t//let groupFieldName = vkey + \"Group\";\r\n\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.value = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.workingValue = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.average = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\tthis.postProcessSeriesDataItem(newDataItem, interval);\r\n\r\n\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\r\n\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tnewDataItem.groupDataItems = [dataItem];\r\n\t\t\t\t\t\t\tpreviousTime = currentTime;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tlet groupFieldName = (<any>series.groupFields)[vkey];\r\n\t\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (!$type.isNumber(values.open)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.low > value || !$type.isNumber(values.low)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.high < value || !$type.isNumber(values.high)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values.sum)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum += value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.count++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.average = values.sum / values.count;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values[groupFieldName])) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.value = values[groupFieldName];\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.workingValue = values.value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(dataItem.properties, newDataItem.properties);\r\n\r\n\t\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\t\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tnewDataItem.groupDataItems.push(dataItem);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t$utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tif (newDataItem && series._adapterO) {\r\n\r\n\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis.calculateZoom();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getDFFormatter() {\r\n\t\tthis._df = this.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItem description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic postProcessSeriesDataItem(dataItem: XYSeriesDataItem, interval?: ITimeInterval): void {\r\n\t\t// we need to do this for all series data items not only added recently, as baseInterval might change\r\n\t\tlet intervalID = \"\";\r\n\t\tif (interval) {\r\n\t\t\tintervalID = interval.timeUnit + interval.count;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinterval = this.mainBaseInterval;\r\n\t\t}\r\n\r\n\t\tlet series: XYSeries = dataItem.component;\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\t$object.each(dataItem.dates, (key) => {\r\n\t\t\tlet date: Date = dataItem.getDate(key);\r\n\t\t\tlet time = date.getTime();\r\n\r\n\t\t\tlet startDate: Date = $time.round(\r\n\t\t\t\tnew Date(time),\r\n\t\t\t\tinterval.timeUnit,\r\n\t\t\t\tinterval.count,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet startTime = startDate.getTime();\r\n\t\t\tlet endDate: Date = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc);\r\n\r\n\t\t\tdataItem.setCalculatedValue(key, startTime, \"open\");\r\n\t\t\tdataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n\t\t\tdataItemsByAxis.setKey(startTime + intervalID, dataItem);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n\t * elements for them.\r\n\t *\r\n\t * Can be used to automatically remove strethes without data, like weekends.\r\n\t *\r\n\t * No, need to call this manually. It will automatically be done if\r\n\t * `skipEmptyPeriods = true`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected addEmptyUnitsBreaks(): void {\r\n\r\n\t\tif (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n\t\t\tlet timeUnit: TimeUnit = this.baseInterval.timeUnit;\r\n\t\t\tlet count: number = this.baseInterval.count;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\tthis._axisBreaks.clear(); // TODO: what about breaks added by user?\r\n\t\t\t}\r\n\r\n\t\t\tlet date: Date = $time.round(\r\n\t\t\t\tnew Date(this.min),\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\tcount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet axisBreak: DateAxisBreak;\r\n\r\n\t\t\twhile (date.getTime() < this.max - this.baseDuration) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\t\t\tlet startTime: number = date.getTime();\r\n\t\t\t\tlet startTimeStr: string = startTime.toString();\r\n\r\n\t\t\t\tlet hasData = $iter.contains(this.series.iterator(), (series) => {\r\n\t\t\t\t\treturn !!series.dataItemsByAxis.getKey(this.uid).getKey(startTimeStr + series.currentDataSetId);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// open break if not yet opened\r\n\t\t\t\tif (!hasData) {\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\taxisBreak = <DateAxisBreak>this.axisBreaks.create();\r\n\t\t\t\t\t\taxisBreak.startDate = new Date(startTime);\r\n\t\t\t\t\t\tthis._gapBreaks = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// close if already opened\r\n\t\t\t\t\tif (axisBreak) {\r\n\t\t\t\t\t\t// close at end time minus one millisecond\r\n\t\t\t\t\t\taxisBreak.endDate = new Date(startTime - 1);\r\n\t\t\t\t\t\taxisBreak = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates positioning of Axis breaks after something changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic fixAxisBreaks(): void {\r\n\t\tsuper.fixAxisBreaks();\r\n\t\tlet axisBreaks = this._axisBreaks;\r\n\t\tif (axisBreaks) {\r\n\t\t\tif (axisBreaks.length > 0) {\r\n\t\t\t\t// process breaks\r\n\t\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\t\tlet breakGridCount: number = Math.ceil(this._gridCount * (Math.min(this.end, axisBreak.endPosition) - Math.max(this.start, axisBreak.startPosition)) / (this.end - this.start));\r\n\t\t\t\t\taxisBreak.gridInterval = this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n\t\t\t\t\tlet gridDate = $time.round(\r\n\t\t\t\t\t\tnew Date(axisBreak.adjustedStartValue),\r\n\t\t\t\t\t\taxisBreak.gridInterval.timeUnit,\r\n\t\t\t\t\t\taxisBreak.gridInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n\t\t\t\t\t\t$time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, this._df.utc);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\taxisBreak.gridDate = gridDate;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getFirstWeekDay(): number {\r\n\t\tif (this._df) {\r\n\t\t\treturn this._df.firstDayOfWeek;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param date           [description]\r\n\t * @param intervalCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getGridDate(date: Date, intervalCount: number): Date {\r\n\t\tlet timeUnit: TimeUnit = this._gridInterval.timeUnit;\r\n\t\tlet realIntervalCount: number = this._gridInterval.count;\r\n\t\t// round date\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\t1,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tlet prevTimestamp: number = date.getTime();\r\n\r\n\t\tlet newDate: Date = $time.copy(date);\r\n\t\t// modify date by adding intervalcount\r\n\t\tlet timestamp: number = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\r\n\r\n\t\t// if it's axis break, get first rounded date which is not in a break\r\n\t\tlet axisBreak: DateAxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak && axisBreak.endDate) {\r\n\t\t\tnewDate = new Date(axisBreak.endDate.getTime());\r\n\t\t\t$time.round(\r\n\t\t\t\tnewDate,\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\trealIntervalCount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tif (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n\t\t\t\t$time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\r\n\t\t\t}\r\n\t\t\ttimestamp = newDate.getTime();\r\n\t\t}\r\n\r\n\t\t// get duration between grid lines with break duration removed\r\n\t\tlet durationBreaksRemoved: number = this.adjustDifference(prevTimestamp, timestamp);\r\n\t\t// calculate how many time units fit to this duration\r\n\t\tlet countBreaksRemoved: number = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n\r\n\t\t// if less units fit, add one and repeat\r\n\t\tif (countBreaksRemoved < realIntervalCount) {\r\n\t\t\treturn this.getGridDate(date, intervalCount + realIntervalCount);\r\n\t\t}\r\n\r\n\t\treturn newDate;\r\n\t}\r\n\r\n\t/**\r\n\t * [getBreaklessDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param axisBreak  [description]\r\n\t * @param timeUnit   [description]\r\n\t * @param count      [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getBreaklessDate(axisBreak: DateAxisBreak, timeUnit: TimeUnit, count: number): Date {\r\n\t\tlet date = new Date(axisBreak.endValue);\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\tlet timestamp = date.getTime();\r\n\r\n\t\taxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak) {\r\n\t\t\treturn this.getBreaklessDate(axisBreak, timeUnit, count);\r\n\t\t}\r\n\t\treturn date;\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates all Axis elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateAxisElements(): void {\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\r\n\t\t\tthis.calculateZoom();\r\n\r\n\t\t\t// first regular items\r\n\t\t\tlet timestamp = this._gridDate.getTime();\r\n\t\t\tlet timeUnit = this._gridInterval.timeUnit;\r\n\t\t\tlet intervalCount = this._gridInterval.count;\r\n\t\t\tlet prevGridDate = $time.copy(this._gridDate);\r\n\r\n\t\t\tlet dataItemsIterator = this._dataItemsIterator;\r\n\t\t\tthis.resetIterators();\r\n\r\n\t\t\twhile (timestamp <= this._maxZoomed) {\r\n\t\t\t\tlet date = this.getGridDate($time.copy(prevGridDate), intervalCount);\r\n\t\t\t\ttimestamp = date.getTime();\r\n\r\n\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet text = this._df.format(date, format);\r\n\r\n\t\t\t\tlet dataItem = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.appendDataItem(dataItem);\r\n\r\n\t\t\t\tdataItem.axisBreak = undefined;\r\n\t\t\t\tdataItem.date = date;\r\n\t\t\t\tdataItem.endDate = endDate;\r\n\r\n\t\t\t\tdataItem.text = text;\r\n\r\n\t\t\t\tthis.validateDataElement(dataItem);\r\n\r\n\t\t\t\tprevGridDate = date;\r\n\t\t\t}\r\n\r\n\t\t\t// breaks later\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\t$iter.each(this._axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\tlet timeUnit: TimeUnit = axisBreak.gridInterval.timeUnit;\r\n\t\t\t\t\t\tlet intervalCount: number = axisBreak.gridInterval.count;\r\n\r\n\t\t\t\t\t\t// only add grid if gap is bigger then minGridDistance\r\n\t\t\t\t\t\tif ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer.minGridDistance * 4) {\r\n\t\t\t\t\t\t\tlet timestamp: number = axisBreak.gridDate.getTime();\r\n\r\n\t\t\t\t\t\t\tlet prevGridDate;\r\n\t\t\t\t\t\t\tlet count: number = 0;\r\n\t\t\t\t\t\t\twhile (timestamp <= axisBreak.adjustedMax) {\r\n\t\t\t\t\t\t\t\tlet date: Date = $time.copy(axisBreak.gridDate);\r\n\t\t\t\t\t\t\t\ttimestamp = $time.add(date, timeUnit, intervalCount * count, this._df.utc).getTime();\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t\tif (timestamp > axisBreak.adjustedStartValue && timestamp < axisBreak.adjustedEndValue) {\r\n\t\t\t\t\t\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\t\t\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\t\t\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\t\t\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\t\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet text: string = this._df.format(date, format);\r\n\r\n\t\t\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\t\t\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t//this.processDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tdataItem.axisBreak = axisBreak;\r\n\t\t\t\t\t\t\t\t\taxisBreak.dataItems.moveValue(dataItem);\r\n\r\n\t\t\t\t\t\t\t\t\tdataItem.date = date;\r\n\t\t\t\t\t\t\t\t\tdataItem.endDate = endDate;\r\n\t\t\t\t\t\t\t\t\tdataItem.text = text;\r\n\t\t\t\t\t\t\t\t\tprevGridDate = date;\r\n\t\t\t\t\t\t\t\t\tthis.validateDataElement(dataItem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]): void {\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tlet timestamp = dataItem.value;\r\n\t\t\tlet endTimestamp = dataItem.endValue;\r\n\r\n\t\t\tif (!$type.isNumber(endTimestamp)) {\r\n\t\t\t\tendTimestamp = timestamp;\r\n\t\t\t}\r\n\r\n\t\t\tlet position: number = this.valueToPosition(timestamp);\r\n\t\t\tlet endPosition: number = this.valueToPosition(endTimestamp);\r\n\t\t\tlet fillEndPosition = endPosition;\r\n\r\n\t\t\tif (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n\t\t\t\tendPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n\t\t\t}\r\n\r\n\t\t\tdataItem.position = position;\r\n\r\n\t\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\t\tif (tick && !tick.disabled) {\r\n\t\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet grid: Grid = dataItem.grid;\r\n\t\t\tif (grid && !grid.disabled) {\r\n\t\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\t\tif (fill && !fill.disabled) {\r\n\t\t\t\trenderer.updateFillElement(fill, position, fillEndPosition);\r\n\t\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\t\tthis.fillRule(dataItem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\t\tif (mask) {\r\n\t\t\t\trenderer.updateFillElement(mask, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.bullet) {\r\n\t\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet label: AxisLabel = dataItem.label;\r\n\t\t\tif (label && !label.disabled) {\r\n\t\t\t\tlet location = label.location;\r\n\r\n\r\n\r\n\t\t\t\tif (location == 0) {\r\n\t\t\t\t\tif (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n\t\t\t\t\t\tlocation = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlocation = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\trenderer.updateLabelElement(label, position, endPosition, location);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A duration in milliseconds of the `baseInterval`.\r\n\t *\r\n\t * @return Duration (ms)\r\n\t */\r\n\tpublic get baseDuration(): number {\r\n\t\treturn $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts min/max values.\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description (review)\r\n\t * @param min  Min timestamp\r\n\t * @param max  Max timestamp\r\n\t * @return Adjusted min/max step\r\n\t */\r\n\tpublic adjustMinMax(min: number, max: number): IMinMaxStep {\r\n\t\treturn { min: min, max: max, step: this.baseDuration };\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the minimum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMin(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.startLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the maximum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMax(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.endLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * [chooseInterval description]\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description\r\n\t * @param index      [description]\r\n\t * @param duration   [description]\r\n\t * @param gridCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic chooseInterval(index: number, duration: number, gridCount: number, intervals?: List<ITimeInterval>): ITimeInterval {\r\n\t\tif (!intervals) {\r\n\t\t\tintervals = this.gridIntervals;\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = intervals.getIndex(index);\r\n\r\n\t\tlet intervalDuration: number = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tlet lastIndex: number = intervals.length - 1;\r\n\t\tif (index >= lastIndex) {\r\n\t\t\treturn { ...intervals.getIndex(lastIndex) };\r\n\t\t}\r\n\r\n\t\tlet count: number = Math.ceil(duration / intervalDuration);\r\n\r\n\t\tif (duration < intervalDuration && index > 0) {\r\n\t\t\treturn { ...intervals.getIndex(index - 1) };\r\n\t\t}\r\n\t\tif (count <= gridCount) {\r\n\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t} else {\r\n\t\t\tif (index + 1 < intervals.length) {\r\n\t\t\t\treturn this.chooseInterval(index + 1, duration, gridCount, intervals);\r\n\t\t\t} else {\r\n\t\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the value according to axis' own [[DateFormatter]].\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Formatted value\r\n\t */\r\n\tpublic formatLabel(value: number): string {\r\n\t\treturn this._df.format(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Date to an asbolute pixel position within Axis.\r\n\t *\r\n\t * @param date  Date\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic dateToPosition(date: Date): number {\r\n\t\treturn this.valueToPosition(date.getTime());\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n\t *\r\n\t * @param date  Date or a timestamp\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(date: Date | number): number {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPosition(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPosition(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts date to orientation point (x, y, angle) on axis\r\n\t *\r\n\t * @param date Date\r\n\t * @return IOrientationPoint\r\n\t */\r\n\tpublic dateToPoint(date: Date): IOrientationPoint {\r\n\t\tlet position = this.dateToPosition(date);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a numeric value to orientation (x, y, angle) point on axis\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic anyToPoint(date: Date | number): IOrientationPoint {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPoint(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPoint(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts pixel position within Axis to a corresponding Date.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Date\r\n\t */\r\n\tpublic positionToDate(position: number): Date {\r\n\t\treturn new Date(this.positionToValue(position));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\t//let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack ID\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(stackKey, \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * [getTimeByLocation description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  [description]\r\n\t * @param key       [description]\r\n\t * @param location  [description]\r\n\t * @return [description]\r\n\t */\r\n\tprotected getTimeByLocation(dataItem: XYSeriesDataItem, key: string, location: number): number {\r\n\r\n\t\tif (!$type.hasValue(key)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = dataItem.workingLocations[key];\r\n\r\n\t\t\tif (!$type.isNumber(location)) {\r\n\t\t\t\tlocation = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet startTime: number = dataItem.values[key][\"open\"];\r\n\t\tlet endTime: number = dataItem.values[key][\"close\"];\r\n\r\n\t\tlet workingValue = dataItem.values[key].workingValue;\r\n\t\tlet value = dataItem.values[key].value;\r\n\r\n\t\tlet difference = value - workingValue;\r\n\t\tstartTime -= difference;\r\n\t\tendTime -= difference;\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\t\t\treturn startTime + (endTime - startTime) * location;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tlet series = dataItem.component;\r\n\t\tlet time: number;\r\n\r\n\t\tlet date: Date = (<any>dataItem)[\"date\" + axisLetter];\r\n\r\n\t\tif ($type.isNumber(this.timezoneOffset)) {\r\n\t\t\tdate.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000)\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t}\r\n\t\telse if ($type.hasValue(this.timezone)) {\r\n\t\t\tdate = $time.setTimezone(date, this.timezone);\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t\t(<any>dataItem)[\"date\" + axisLetter] = date;\r\n\t\t}\r\n\r\n\t\tif (date) {\r\n\t\t\ttime = date.getTime();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet openDate: Date = (<any>dataItem)[\"openDate\" + axisLetter];\r\n\t\tlet prevSeriesTime: number = this._prevSeriesTime[series.uid];\r\n\r\n\r\n\t\tlet openTime: number;\r\n\t\tif (openDate) {\r\n\t\t\topenTime = openDate.getTime();\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(openTime)) {\r\n\t\t\tlet difference = Math.abs(time - openTime);\r\n\r\n\t\t\tif (this._minDifference[series.uid] > difference) {\r\n\t\t\t\tthis._minDifference[series.uid] = difference;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet differece: number = time - prevSeriesTime;\r\n\r\n\t\tif (differece > 0) {\r\n\t\t\tif (this._minDifference[series.uid] > differece) {\r\n\t\t\t\tthis._minDifference[series.uid] = differece;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._prevSeriesTime[series.uid] = time;\r\n\r\n\t\tif (series._baseInterval[this.uid]) {\r\n\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [updateAxisBySeries description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic updateAxisBySeries() {\r\n\t\tsuper.updateAxisBySeries();\r\n\r\n\t\tlet baseInterval: ITimeInterval = this.chooseInterval(0, this.minDifference, 1);\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n\t\t\tbaseInterval.timeUnit = \"month\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\t\tif (baseInterval.timeUnit == \"month\") {\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\r\n\t\t\t\tbaseInterval.count = 2;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\r\n\t\t\t\tbaseInterval.count = 3;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\r\n\t\t\t\tbaseInterval.count = 6;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// handle daylight saving\r\n\t\tif (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n\t\t\tbaseInterval.timeUnit = \"day\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n\t\t\tbaseInterval.timeUnit = \"week\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n\t\t\tbaseInterval.timeUnit = \"year\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tthis._baseIntervalReal = baseInterval;\r\n\t\tthis._mainBaseInterval = baseInterval;\r\n\r\n\t\t// no need to invalidate\r\n\t}\r\n\r\n\t/**\r\n\t * A base interval (granularity) of data.\r\n\t *\r\n\t * Used to indicate what are the base units of your data.\r\n\t *\r\n\t * For example, if you have a data set that has a data point every 5 minutes,\r\n\t * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n\t *\r\n\t * If not set, the Axis will try to determine the setting by its own, looking\r\n\t * at actual data.\r\n\t *\r\n\t * For best results, try to follow these values for `count`:\r\n\t *\r\n\t * When unit is \"month\", use 12 / count = round number\r\n\t * When unit is \"hour\", use 24 / count = round number\r\n\t * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n\t *\r\n\t * @param timeInterval base interval\r\n\t */\r\n\tpublic set baseInterval(timeInterval: ITimeInterval) {\r\n\t\tif (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n\t\t\tthis._baseInterval = timeInterval;\r\n\t\t\tthis._mainBaseInterval = timeInterval;\r\n\t\t\tif (!$type.isNumber(timeInterval.count)) {\r\n\t\t\t\ttimeInterval.count = 1;\r\n\t\t\t}\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base interval\r\n\t */\r\n\tpublic get baseInterval(): ITimeInterval {\r\n\t\tif (this._groupInterval) {\r\n\t\t\treturn this._groupInterval;\r\n\t\t}\r\n\t\telse if (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates granularity of the data of source (unaggregated) data.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @return Granularity of the main data set\r\n\t */\r\n\tpublic get mainBaseInterval(): ITimeInterval {\r\n\t\tif (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse if (this._mainBaseInterval) {\r\n\t\t\treturn this._mainBaseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * An \"empty\" period is considered a stretch of time in the length of current\r\n\t * `baseInterval` without a single data point in it.\r\n\t *\r\n\t * For each such empty period, axis will automatically create an\r\n\t * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n\t * them by accessing `axis.breaks.template`.\r\n\t *\r\n\t * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n\t *\r\n\t * Important notes:\r\n\t * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n\t * * Using this feature affects performance. Use only if you need it.\r\n\t * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n\t * * Some axis label overlapping might happen.\r\n\t * * This setting is not compatible with `groupData = true`.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Remove empty stretches of time?\r\n\t */\r\n\tpublic set skipEmptyPeriods(value: boolean) {\r\n\r\n\t\tif (value) {\r\n\t\t\tlet breakTemplate = this.axisBreaks.template;\r\n\t\t\tbreakTemplate.startLine.disabled = true;\r\n\t\t\tbreakTemplate.endLine.disabled = true;\r\n\t\t\tbreakTemplate.fillShape.disabled = true;\r\n\t\t\tbreakTemplate.breakSize = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._gapBreaks) {\r\n\t\t\t\tthis.axisBreaks.clear();\r\n\t\t\t\tthis._gapBreaks = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Remove empty stretches of time?\r\n\t */\r\n\tpublic get skipEmptyPeriods(): boolean {\r\n\t\treturn this.getPropertyValue(\"skipEmptyPeriods\");\r\n\t}\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t *\r\n\t * @param value  Date format\r\n\t */\r\n\tpublic set tooltipDateFormat(value: string | Intl.DateTimeFormatOptions) {\r\n\t\tthis.setPropertyValue(\"tooltipDateFormat\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date format\r\n\t */\r\n\tpublic get tooltipDateFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.getPropertyValue(\"tooltipDateFormat\");\r\n\t}\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tpublic set markUnitChange(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"markUnitChange\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use different format for period beginning?\r\n\t */\r\n\tpublic get markUnitChange(): boolean {\r\n\t\treturn this.getPropertyValue(\"markUnitChange\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a tooltip, based on specific relative position\r\n\t * within axis.\r\n\t *\r\n\t * The label will be formatted as per [[DateFormatter]] set for the whole\r\n\t * chart, or explicitly for this Axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position\r\n\t * @return Label (formatted date)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet text: string;\r\n\t\tlet date = this.positionToDate(position);\r\n\t\tdate = $time.round(\r\n\t\t\tdate,\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tthis.tooltipDate = date;\r\n\r\n\t\tif ($type.hasValue(this.tooltipDateFormat)) {\r\n\t\t\ttext = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n\t\t\tif (dateFormat) {\r\n\t\t\t\ttext = this._df.format(date, dateFormat);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttext = this.getPositionLabel(position);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn text;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\"getTooltipText\", text);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position Source position\r\n\t * @param location  Location in the cell\r\n\t * @return Adjusted position\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation, axisLocation?: number): number {\r\n\t\tlet baseInterval = this.baseInterval;\r\n\t\tlet timeUnit = baseInterval.timeUnit;\r\n\t\tlet count = baseInterval.count;\r\n\r\n\t\tlet date: Date = this.positionToDate(position);\r\n\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (location > 0) {\r\n\t\t\t$time.add(date, timeUnit, location * count, this._df.utc);\r\n\t\t}\r\n\r\n\t\tif (axisLocation > 0 && axisLocation < 1) {\r\n\t\t\tdate.setTime(date.getTime() + this.baseDuration * axisLocation);\r\n\t\t}\r\n\r\n\t\tif (this.isInBreak(date.getTime())) {\r\n\t\t\twhile (date.getTime() < this.max) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\t\t\t\tif (!this.isInBreak(date.getTime())) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.dateToPosition(date);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell start relative position\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell end relative position\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t\t//return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a Series data item that corresponds to the specific pixel position\r\n\t * of the Axis.\r\n\t *\r\n\t * If `findNearest` (third parameter) is set to `true`, the method will try\r\n\t * to locate nearest available data item if none is found directly under\r\n\t * `position`.\r\n\t *\r\n\t * @param series       Series\r\n\t * @param position     Position (px)\r\n\t * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n\t * @return Data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tlet value: number = this.positionToValue(position);\r\n\r\n\t\tlet location = 0.5;\r\n\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\tlocation = series.dataItems.template.locations.dateY;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlocation = series.dataItems.template.locations.dateX;\r\n\t\t}\r\n\r\n\t\tlet deltaValue = value - location * this.baseDuration;\r\n\r\n\t\tlet date: Date = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\tlet nextDate: Date = $time.round(\r\n\t\t\tnew Date(value + this.baseDuration),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (nextDate.getTime() > date.getTime()) {\r\n\t\t\tif (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\r\n\t\t\t\tdate = nextDate;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\tlet dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\r\n\r\n\t\t// todo:  alternatively we can find closiest here\r\n\t\tif (!dataItem && findNearest) {\r\n\r\n\t\t\tlet key: \"dateX\" | \"dateY\";\r\n\r\n\t\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\t\tkey = \"dateY\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tkey = \"dateX\";\r\n\t\t\t}\r\n\r\n\t\t\tdataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), (x) => {\r\n\t\t\t\tif (x[key]) {\r\n\t\t\t\t\treturn <number>x[key].getTime();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn -Infinity;\r\n\t\t\t\t}\r\n\t\t\t}, \"any\"));\r\n\t\t}\r\n\r\n\t\treturn dataItem;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a formatted date based on position in axis scale.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\t// @todo Better format recognition\r\n\t\tlet date = this.positionToDate(position);\r\n\t\treturn this._df.format(date, this.getCurrentLabelFormat());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label date format based on currently used time units\r\n\t *\r\n\t * @return Format\r\n\t */\r\n\tprotected getCurrentLabelFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes an Axis renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\t\tlet renderer = this.renderer;\r\n\t\tif (renderer) {\r\n\t\t\t// Set defaults\r\n\t\t\trenderer.ticks.template.location = 0;\r\n\t\t\trenderer.grid.template.location = 0;\r\n\t\t\trenderer.labels.template.location = 0;\r\n\t\t\trenderer.baseGrid.disabled = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\treturn { x: 0, y: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected animateMinMax(min: number, max: number): Animation {\r\n\t\tlet animation = this.animate([{ property: \"_minAdjusted\", from: this._minAdjusted, to: min }, { property: \"_maxAdjusted\", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);\r\n\t\tanimation.events.on(\"animationprogress\", () => {\r\n\t\t\tthis.dispatch(\"extremeschanged\");\r\n\t\t})\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates axis data items when series extremes change\r\n\t */\r\n\tprotected handleExtremesChange() {\r\n\t\tsuper.handleExtremesChange();\r\n\r\n\t\tif (this.groupData) {\r\n\t\t\tlet id = this.baseInterval.timeUnit + this.baseInterval.count;\r\n\t\t\tthis.groupMin[id] = this._finalMin;\r\n\t\t\tthis.groupMax[id] = this._finalMax;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Zooms axis to specific Dates.\r\n\t *\r\n\t * @param startDate       Start date\r\n\t * @param endValue        End date\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToDates(startDate: Date, endDate: Date, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tstartDate = this._df.parse(startDate);\r\n\t\tendDate = this._df.parse(endDate);\r\n\t\tthis.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms axis to specific values.\r\n\t *\r\n\t * @param startValue      Start value\r\n\t * @param endValue        End value\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToValues(startValue: number, endValue: number, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tif (!this.groupData) {\r\n\t\t\t//let start: number = (startValue - this.min) / (this.max - this.min);\r\n\t\t\t//let end: number = (endValue - this.min) / (this.max - this.min);\r\n\r\n\t\t\tlet start = this.valueToPosition(startValue);\r\n\t\t\tlet end = this.valueToPosition(endValue);\r\n\r\n\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet difference = this.adjustDifference(startValue, endValue);\r\n\t\t\tlet isEnd = false;\r\n\t\t\tif (endValue == this.max) {\r\n\t\t\t\tisEnd = true;\r\n\t\t\t}\r\n\t\t\tlet isStart = false;\r\n\t\t\tif (startValue == this.min) {\r\n\t\t\t\tisStart = true;\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.hasValue(difference)) {\r\n\t\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\t\tlet groupInterval = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\r\n\r\n\t\t\t\tif ((groupInterval.timeUnit == mainBaseInterval.timeUnit && groupInterval.count < mainBaseInterval.count) || $time.getDuration(groupInterval.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet id = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\t\tlet min = this.groupMin[id];\r\n\t\t\t\tlet max = this.groupMax[id];\r\n\r\n\t\t\t\tif (!$type.isNumber(min) || !$type.isNumber(max)) {\r\n\t\t\t\t\tmin = Number.POSITIVE_INFINITY;\r\n\t\t\t\t\tmax = Number.NEGATIVE_INFINITY;\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\t\t\t\t\t\tlet seriesMin = series.min(this);\r\n\t\t\t\t\t\tlet seriesMax = series.max(this);\r\n\r\n\t\t\t\t\t\tif (series._dataSets) {\r\n\t\t\t\t\t\t\tlet ds = series._dataSets.getKey(groupInterval.timeUnit + groupInterval.count);\r\n\r\n\t\t\t\t\t\t\tif (ds) {\r\n\t\t\t\t\t\t\t\tlet mindi = ds.getIndex(0);\r\n\t\t\t\t\t\t\t\tlet maxdi = ds.getIndex(ds.length - 1);\r\n\r\n\t\t\t\t\t\t\t\tif (mindi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (maxdi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseriesMax = $time.round(\r\n\t\t\t\t\t\t\t$time.add(new Date(seriesMax), groupInterval.timeUnit, 1, this._df.utc),\r\n\t\t\t\t\t\t\tgroupInterval.timeUnit,\r\n\t\t\t\t\t\t\t1,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t).getTime();\r\n\r\n\t\t\t\t\t\tif (seriesMin < min) {\r\n\t\t\t\t\t\t\tmin = seriesMin;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (seriesMax > max) {\r\n\t\t\t\t\t\t\tmax = seriesMax;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tthis.groupMin[id] = min;\r\n\t\t\t\t\tthis.groupMax[id] = max;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\r\n\t\t\t\tif (adjust) {\r\n\t\t\t\t\tif (isEnd) {\r\n\t\t\t\t\t\tstartValue = endValue - difference;\r\n\t\t\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isStart) {\r\n\t\t\t\t\t\tendValue = startValue + difference;\r\n\t\t\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet start: number = (startValue - min) / (max - min);\r\n\t\t\t\tlet end: number = (endValue - min) / (max - min);\r\n\r\n\t\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `baseInterval` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"baseInterval\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from a different instance of Axis.\r\n\t *\r\n\t * @param source Source Axis\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.dateFormats = source.dateFormats;\r\n\t\tthis.periodChangeDateFormats = source.periodChangeDateFormats;\r\n\t\tthis.groupIntervals.clear();\r\n\t\tsource.groupIntervals.each((interval) => {\r\n\t\t\tthis.groupIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tthis.gridIntervals.clear();\r\n\t\tsource.gridIntervals.each((interval) => {\r\n\t\t\tthis.gridIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tif (source._baseInterval) {\r\n\t\t\tthis.baseInterval = source._baseInterval;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n\t *\r\n\t * @param position Position (0-1)\r\n\t * @param local or global position\r\n\t */\r\n\tpublic showTooltipAtPosition(position: number, local?: boolean) {\r\n\r\n\t\tif (!local) {\r\n\t\t\tposition = this.toAxisPosition(position);\r\n\t\t}\r\n\r\n\t\tif (this.snapTooltip) {\r\n\t\t\t// rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\r\n\t\t\tlet actualDate = this.positionToDate(position) //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n\r\n\t\t\tlet actualTime = actualDate.getTime();\r\n\t\t\tlet closestDate: Date;\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet dataItem = this.getSeriesDataItem(series, position, true);\r\n\r\n\t\t\t\t\tif (dataItem) {\r\n\t\t\t\t\t\tlet date: Date;\r\n\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateX;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateY;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!closestDate) {\r\n\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (Math.abs(closestDate.getTime() - actualTime) > Math.abs(date.getTime() - actualTime)) {\r\n\t\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (closestDate) {\r\n\t\t\t\tlet closestTime = closestDate.getTime();\r\n\t\t\t\tclosestDate = $time.round(\r\n\t\t\t\t\tnew Date(closestTime),\r\n\t\t\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\t\t\tthis.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t);\r\n\t\t\t\tclosestTime = closestDate.getTime();\r\n\r\n\t\t\t\tlet tooltipLocation = this.renderer.tooltipLocation;\r\n\t\t\t\tif (tooltipLocation == 0) {\r\n\t\t\t\t\ttooltipLocation = 0.0001;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclosestDate = new Date(closestDate.getTime() + this.baseDuration * tooltipLocation);\r\n\t\t\t\tposition = this.dateToPosition(closestDate);\r\n\r\n\t\t\t\tif (this.chart.cursor && this.chart.cursor.snapToSeries) {\r\n\t\t\t\t\t//void\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\r\n\t\t\t\t\t\tlet dataItem = series.dataItemsByAxis.getKey(this.uid).getKey(closestTime + series.currentDataSetId);\r\n\t\t\t\t\t\tlet point = series.showTooltipAtDataItem(dataItem);\r\n\t\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\t\tthis.chart._seriesPoints.push({ series: series, point: point });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// check, otherwise column tooltip will be hidden\r\n\t\t\t\t\t\t\tif (series.tooltipText || series.tooltipHTML) {\r\n\t\t\t\t\t\t\t\tseries.hideTooltip();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//this.chart.sortSeriesTooltips(seriesPoints);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.showTooltipAtPosition(position, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Should snap?\r\n\t */\r\n\tpublic set snapTooltip(value: boolean) {\r\n\t\tthis.setPropertyValue(\"snapTooltip\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should snap?\r\n\t */\r\n\tpublic get snapTooltip(): boolean {\r\n\t\treturn this.getPropertyValue(\"snapTooltip\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * Grouping will occur automatically, based on current selection range, and\r\n\t * will change dynamically when user zooms in/out the chart.\r\n\t *\r\n\t * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n\t *\r\n\t * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n\t * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n\t *\r\n\t * The group intervals to aggregate data to is defined by `groupIntervals`\r\n\t * property.\r\n\t *\r\n\t * ```TypeScript\r\n\t * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * let series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * var series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     \"type\": \"DateAxis\",\r\n\t *     \"groupData\": true\r\n\t *   }],\r\n\t *   \"yAxes\": [{\r\n\t *     \"type\": \"ValueAxis\"\r\n\t *   }],\r\n\t *   \"series\": [{\r\n\t *     \"type\": \"LineSeries\",\r\n\t *     \"dataFields\": {\r\n\t *       \"dateX\": \"date\",\r\n\t *       \"valueY\": \"value\"\r\n\t *     },\r\n\t *     \"groupFields\": {\r\n\t *       \"valueY\": \"average\"\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @default false\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t * @since 4.7.0\r\n\t * @param  value  Group data points?\r\n\t */\r\n\tpublic set groupData(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"groupData\", value)) {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tseries.setDataSet(\"\");\r\n\r\n\t\t\t\tif (value && !series.dataGrouped && series.inited) {\r\n\t\t\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\t\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis._currentDataSetId = \"\"\r\n\t\t\tthis._groupInterval = undefined;\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Group data points?\r\n\t */\r\n\tpublic get groupData(): boolean {\r\n\t\treturn this.getPropertyValue(\"groupData\");\r\n\t}\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t * @param  value  Interval\r\n\t */\r\n\tpublic set groupInterval(value: ITimeInterval) {\r\n\t\tif (this.setPropertyValue(\"groupInterval\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Interval\r\n\t */\r\n\tpublic get groupInterval(): ITimeInterval {\r\n\t\treturn this.getPropertyValue(\"groupInterval\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t * @param  value  Number of data items\r\n\t */\r\n\tpublic set groupCount(value: number) {\r\n\t\tthis.setPropertyValue(\"groupCount\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Number of data items\r\n\t */\r\n\tpublic get groupCount(): number {\r\n\t\treturn this.getPropertyValue(\"groupCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t * \r\n\t * @since 4.8.5\r\n\t * @param  value Time zone offset in minutes\r\n\t */\r\n\tpublic set timezoneOffset(value: number) {\r\n\t\tthis.setPropertyValue(\"timezoneOffset\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @todo Timezone offset in minutes\r\n\t */\r\n\tpublic get timezoneOffset(): number {\r\n\t\treturn this.getPropertyValue(\"timezoneOffset\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: it is no longer recommended to use this setting. Please \r\n\t * set`timezone` on `dateFormatter`.\r\n\t *\r\n\t * @deprecated\r\n\t * @since 4.10.1\r\n\t * @param  value Time zone\r\n\t */\r\n\tpublic set timezone(value: string) {\r\n\t\tthis.setPropertyValue(\"timezone\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Timezone\r\n\t */\r\n\tpublic get timezone(): string {\r\n\t\treturn this.getPropertyValue(\"timezone\");\r\n\t}\r\n\r\n\t/**\r\n\t * Current grid interval.\r\n\t *\r\n\t * @return Grid interval\r\n\t */\r\n\tpublic get gridInterval(): ITimeInterval {\r\n\t\treturn this._gridInterval;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic makeGap(dataItem: LineSeriesDataItem, previous: LineSeriesDataItem): boolean {\r\n\t\tlet series = dataItem.component;\r\n\t\tif (dataItem && previous) {\r\n\t\t\tif (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet date = dataItem.dates[\"date\" + this.axisLetter];\r\n\t\t\t\t\tlet prevDate = previous.dates[\"date\" + this.axisLetter];\r\n\r\n\t\t\t\t\tif (date && prevDate) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\tlet prevTime = prevDate.getTime();\r\n\r\n\t\t\t\t\t\tif (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @return base value\r\n\t */\r\n\tpublic get baseValue(): number {\r\n\t\treturn this.min;\r\n\t}\r\n\r\n\tprotected _saveMinMax(min: number, max: number) {\r\n\t\tlet groupInterval = this.groupInterval;\r\n\r\n\t\tif (!groupInterval) {\r\n\t\t\tgroupInterval = this.mainBaseInterval;\t\t\t\r\n\t\t}\r\n\r\n\t\tlet id = groupInterval.timeUnit + groupInterval.count;\r\n\r\n\t\tthis._intervalMin[id] = min;\r\n\t\tthis._intervalMax[id] = max;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}