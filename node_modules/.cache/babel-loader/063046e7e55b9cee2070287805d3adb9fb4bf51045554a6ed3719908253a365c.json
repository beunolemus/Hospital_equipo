{"ast":null,"code":"import \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.push.js\";\n/**\r\n * Line series segment module.\r\n * @todo Add description about what this is\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Container } from \"../../core/Container\";\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\nimport { registry } from \"../../core/Registry\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $type from \"../../core/utils/Type\";\nimport { color } from \"../../core/utils/Color\";\nimport * as $smoothing from \"../../core/rendering/Smoothing\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Represents a line series segment.\r\n *\r\n * A line segment can be used to apply different properties to a part of the\r\n * line series, between two data points.\r\n *\r\n * @see {@link ILineSeriesSegmentEvents} for a list of available events\r\n * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\nvar LineSeriesSegment = /** @class */function (_super) {\n  __extends(LineSeriesSegment, _super);\n  /**\r\n   * Constructor\r\n   */\n  function LineSeriesSegment() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this.className = \"LineSeriesSegment\";\n    // Set defaults\n    _this.isMeasured = false;\n    _this.interactionsEnabled = false;\n    _this.layout = \"none\";\n    // Create fill element\n    var fillSprite = _this.createChild(Sprite);\n    _this.fillSprite = fillSprite;\n    fillSprite.shouldClone = false;\n    fillSprite.setElement(_this.paper.add(\"path\"));\n    fillSprite.isMeasured = false;\n    _this._disposers.push(fillSprite);\n    // Create line element\n    var strokeSprite = _this.createChild(Sprite);\n    _this.strokeSprite = strokeSprite;\n    strokeSprite.shouldClone = false;\n    strokeSprite.fill = color();\n    strokeSprite.setElement(_this.paper.add(\"path\"));\n    strokeSprite.isMeasured = false;\n    _this._disposers.push(strokeSprite);\n    return _this;\n  }\n  /**\r\n   * Draws the series segment.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param points       Points to connect\r\n   * @param closePoints  ?\r\n   * @param smoothnessX  Horizontal bezier setting (?)\r\n   * @param smoothnessY  Vertical bezier setting (?)\r\n   */\n  LineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY) {\n    if (!this.disabled) {\n      if (points.length > 0 && closePoints.length > 0 && $type.isNumber(points[0].x) && $type.isNumber(points[0].y)) {\n        // first moveTo helps to avoid Chrome straight line in the mask bug.\n        var path = $path.moveTo({\n          x: points[0].x - 0.2,\n          y: points[0].y - 0.2\n        }) + $path.moveTo(points[0]);\n        var series = this.series;\n        if (series.smoothing == \"bezier\") {\n          path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(points);\n        } else if (series.smoothing == \"monotoneX\") {\n          path += new $smoothing.MonotoneX({\n            closed: false\n          }).smooth(points);\n        } else if (series.smoothing == \"monotoneY\") {\n          path += new $smoothing.MonotoneY({\n            closed: false\n          }).smooth(points);\n        }\n        if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {\n          // like this and not if != 0, otherwise ranges stroke won't be drawn.\n        } else {\n          this.strokeSprite.path = path;\n        }\n        if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {\n          // helps to avoid drawing fill object if fill is not visible\n          if ($type.isNumber(closePoints[0].x) && $type.isNumber(closePoints[0].y)) {\n            path += $path.lineTo(closePoints[0]);\n            if (series.smoothing == \"bezier\") {\n              path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(closePoints);\n            } else if (series.smoothing == \"monotoneX\") {\n              path += new $smoothing.MonotoneX({\n                closed: false\n              }).smooth(closePoints);\n            } else if (series.smoothing == \"monotoneY\") {\n              path += new $smoothing.MonotoneY({\n                closed: false\n              }).smooth(closePoints);\n            }\n            path += $path.lineTo(points[0]);\n            path += $path.closePath();\n            this.fillSprite.path = path;\n          }\n        }\n      } else {\n        this.fillSprite.path = \"\";\n        this.strokeSprite.path = \"\";\n      }\n    }\n  };\n  /**\r\n   * Copies properties from a [[Sprite]] to both line and fill elements.\r\n   *\r\n   * @param source Source [[Sprite]] to copy properties from\r\n   */\n  LineSeriesSegment.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n    var lineElement = this.strokeSprite;\n    $object.copyProperties(source, lineElement.properties, visualProperties);\n    lineElement.events.copyFrom(source.strokeSprite.events);\n    lineElement.fillOpacity = 0;\n    var fillElement = this.fillSprite;\n    $object.copyProperties(source, fillElement.properties, visualProperties);\n    fillElement.events.copyFrom(source.fillSprite.events);\n    fillElement.strokeOpacity = 0;\n  };\n  return LineSeriesSegment;\n}(Container);\nexport { LineSeriesSegment };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"LineSeriesSegment\"] = LineSeriesSegment;","map":{"version":3,"names":["Container","Sprite","visualProperties","registry","$path","$object","$type","color","$smoothing","LineSeriesSegment","_super","__extends","_this","call","className","isMeasured","interactionsEnabled","layout","fillSprite","createChild","shouldClone","setElement","paper","add","_disposers","push","strokeSprite","fill","prototype","drawSegment","points","closePoints","smoothnessX","smoothnessY","disabled","length","isNumber","x","y","path","moveTo","series","smoothing","Tension","smooth","MonotoneX","closed","MonotoneY","strokeOpacity","fillOpacity","lineTo","closePath","copyFrom","source","lineElement","copyProperties","properties","events","fillElement","registeredClasses"],"sources":["../../../../../src/.internal/charts/series/LineSeriesSegment.ts"],"sourcesContent":["/**\r\n * Line series segment module.\r\n * @todo Add description about what this is\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../../core/Container\";\r\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { LineSeries } from \"./LineSeries\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport * as $smoothing from \"../../core/rendering/Smoothing\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[LineSeriesSegment]].\r\n */\r\nexport interface ILineSeriesSegmentProperties extends IContainerProperties { }\r\n\r\n/**\r\n * Defines events for [[LineSeriesSegment]].\r\n */\r\nexport interface ILineSeriesSegmentEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[LineSeriesSegment]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILineSeriesSegmentAdapters extends IContainerAdapters, ILineSeriesSegmentProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents a line series segment.\r\n *\r\n * A line segment can be used to apply different properties to a part of the\r\n * line series, between two data points.\r\n *\r\n * @see {@link ILineSeriesSegmentEvents} for a list of available events\r\n * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\r\nexport class LineSeriesSegment extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILineSeriesSegmentProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ILineSeriesSegmentAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILineSeriesSegmentEvents;\r\n\r\n\t/**\r\n\t * Segment's line element.\r\n\t */\r\n\tpublic strokeSprite: Sprite;\r\n\r\n\t/**\r\n\t * Segment's fill element.\r\n\t */\r\n\tpublic fillSprite: Sprite;\r\n\r\n\tpublic series: LineSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"LineSeriesSegment\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.interactionsEnabled = false;\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\t// Create fill element\r\n\t\tlet fillSprite = this.createChild(Sprite);\r\n\t\tthis.fillSprite = fillSprite;\r\n\t\tfillSprite.shouldClone = false;\r\n\t\tfillSprite.setElement(this.paper.add(\"path\"));\r\n\t\tfillSprite.isMeasured = false;\r\n\t\tthis._disposers.push(fillSprite);\r\n\r\n\r\n\t\t// Create line element\r\n\t\tlet strokeSprite = this.createChild(Sprite);\r\n\t\tthis.strokeSprite = strokeSprite;\r\n\t\tstrokeSprite.shouldClone = false;\r\n\t\tstrokeSprite.fill = color();\r\n\t\tstrokeSprite.setElement(this.paper.add(\"path\"));\r\n\t\tstrokeSprite.isMeasured = false;\r\n\t\tthis._disposers.push(strokeSprite);\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the series segment.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param points       Points to connect\r\n\t * @param closePoints  ?\r\n\t * @param smoothnessX  Horizontal bezier setting (?)\r\n\t * @param smoothnessY  Vertical bezier setting (?)\r\n\t */\r\n\tpublic drawSegment(points: IPoint[], closePoints: IPoint[], smoothnessX: number, smoothnessY: number): void {\r\n\t\tif (!this.disabled) {\r\n\t\t\tif (points.length > 0 && closePoints.length > 0 && $type.isNumber(points[0].x) && $type.isNumber(points[0].y)) {\r\n\t\t\t\t// first moveTo helps to avoid Chrome straight line in the mask bug.\r\n\t\t\t\tlet path: string = $path.moveTo({ x: points[0].x - 0.2, y: points[0].y - 0.2 }) + $path.moveTo(points[0])\r\n\r\n\t\t\t\tlet series = this.series;\r\n\r\n\t\t\t\tif (series.smoothing == \"bezier\") {\r\n\t\t\t\t\tpath += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(points);\r\n\t\t\t\t}\r\n\t\t\t\telse if (series.smoothing == \"monotoneX\") {\r\n\t\t\t\t\tpath += new $smoothing.MonotoneX({ closed: false }).smooth(points);\r\n\t\t\t\t}\r\n\t\t\t\telse if (series.smoothing == \"monotoneY\") {\r\n\t\t\t\t\tpath += new $smoothing.MonotoneY({ closed: false }).smooth(points);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {\r\n\t\t\t\t\t// like this and not if != 0, otherwise ranges stroke won't be drawn.\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.strokeSprite.path = path;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) { // helps to avoid drawing fill object if fill is not visible\r\n\t\t\t\t\tif ($type.isNumber(closePoints[0].x) && $type.isNumber(closePoints[0].y)) {\r\n\t\t\t\t\t\tpath += $path.lineTo(closePoints[0]);\r\n\r\n\t\t\t\t\t\tif (series.smoothing == \"bezier\") {\r\n\t\t\t\t\t\t\tpath += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(closePoints);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (series.smoothing == \"monotoneX\") {\r\n\t\t\t\t\t\t\tpath += new $smoothing.MonotoneX({ closed: false }).smooth(closePoints);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (series.smoothing == \"monotoneY\") {\r\n\t\t\t\t\t\t\tpath += new $smoothing.MonotoneY({ closed: false }).smooth(closePoints);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpath += $path.lineTo(points[0]);\r\n\t\t\t\t\t\tpath += $path.closePath();\r\n\r\n\t\t\t\t\t\tthis.fillSprite.path = path;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.fillSprite.path = \"\";\r\n\t\t\t\tthis.strokeSprite.path = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Copies properties from a [[Sprite]] to both line and fill elements.\r\n\t *\r\n\t * @param source Source [[Sprite]] to copy properties from\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\r\n\t\tlet lineElement = this.strokeSprite;\r\n\t\t$object.copyProperties(source, lineElement.properties, visualProperties);\r\n\t\tlineElement.events.copyFrom(source.strokeSprite.events);\r\n\t\tlineElement.fillOpacity = 0;\r\n\r\n\t\tlet fillElement = this.fillSprite;\r\n\t\t$object.copyProperties(source, fillElement.properties, visualProperties);\r\n\t\tfillElement.events.copyFrom(source.fillSprite.events);\r\n\t\tfillElement.strokeOpacity = 0;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"LineSeriesSegment\"] = LineSeriesSegment;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}